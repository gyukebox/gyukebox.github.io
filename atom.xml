<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GyuLog</title>
  
  <subtitle>Byeong Gyu&#39;s dev blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gyukebox.github.io/"/>
  <updated>2018-01-13T06:15:19.000Z</updated>
  <id>http://gyukebox.github.io/</id>
  
  <author>
    <name>Byeong Gyu Choi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript(0) - 설치와 설정</title>
    <link href="http://gyukebox.github.io/2018/01/13/typescript-settings/"/>
    <id>http://gyukebox.github.io/2018/01/13/typescript-settings/</id>
    <published>2018-01-13T06:15:19.000Z</published>
    <updated>2018-01-13T06:15:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>최근에 TypeScript 를 들여다 보면서 깨달은 내용을 적어봅니다. 첫번째는 역시나 설치와 설정이네요.</p><p><img src="/images/typescript.png" alt=""></p><a id="more"></a><h2 id="TypeScript-란"><a href="#TypeScript-란" class="headerlink" title="TypeScript 란?"></a>TypeScript 란?</h2><blockquote><p>JavaScript that scales.</p><p>TypeScript is a language for application-scale JavaScript. TypeScript adds optional types, classes, and modules to JavaScript. TypeScript supports tools for large-scale JavaScript applications for any browser, for any host, on any OS. TypeScript compiles to readable, standards-based JavaScript. Try it out at the playground, and stay up to date via our blog and Twitter account.</p></blockquote><p>사실 타입스크립트는 자바스크립트다(?) 정확하게는, “자바스크립트의 확장판” 이라고 생각하면 쉽다. 컴파일하여 자바스크립트가 되는 compile-to-javascript 언어이며, ES6을 지원하는 것은 물론이고, 이에 확장하여 타입 시스템, generics, decorators 등을 지원해주는 언어이다.<br>타입 시스템을 도입하면 자바스크립트의 dynamic 한 장점을 없애버리는 것이 아닌가 생각했지만, 선택적으로 사용할 수 있고, 무엇보다 다수의 ES 버전으로 컴파일할 수 있다는 면에서 상당한 매력을 느꼈다.</p><h2 id="TypeScript-설치하기"><a href="#TypeScript-설치하기" class="headerlink" title="TypeScript 설치하기"></a>TypeScript 설치하기</h2><p>npm을 이용하여 설치할 수 있다. 다음과 같이 글로벌하게 설치할 수 있지만,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g typescript</span><br></pre></td></tr></table></figure></p><p>TS가 필요없는 프로젝트가 있을수 있으므로, 그냥 프로젝트 생성 후 로컬로 설치하는 것이 더 좋아 보인다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">$ npm install typescript --save-dev</span><br></pre></td></tr></table></figure></p><p>그 다음, ESLint 처럼 TypeScript 코드를 바로잡아 줄 수 있는 TSLint 도 설치해주면 좋다.  </p><p>만약 yarn 을 사용할 경우,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add typescript tslint</span><br><span class="line">$ yarn add typescript tslint --dev</span><br></pre></td></tr></table></figure></p><p>(첫번째 줄은 글로벌, 두번째 줄은 로컬)<br>위의 명령어를 사용하면 설치할 수 있다.</p><h2 id="TypeScript-기본-설정하기"><a href="#TypeScript-기본-설정하기" class="headerlink" title="TypeScript 기본 설정하기"></a>TypeScript 기본 설정하기</h2><p>설치를 완료하였다면 기본 설정 몇 가지가 남았는데, 타입스크립트 컴파일러 설정과 TSLint 설정이다.<br>다음 두 명령어를 이용하면 공들이지 않고 설정의 기본을 잡을 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./node_modules/.bin/tsc --init</span><br><span class="line">$ ./node_modules/.bin/tslint --init</span><br></pre></td></tr></table></figure><p>일일이 디렉토리를 입력하는 것이 귀찮다면, <a href="https://github.com/zkat/npx" target="_blank" rel="noopener">npx</a>를 도입하는 방법도 나쁘지 않다. npx 는 로컬로 설치한 패키지를 글로벌 패키지처럼 사용할 수 있게 해주는 패키지이다. Webpack 같은 툴 스크립트 쓸 때 사용하면 좋을 것 같기도 하다.</p><p>다음과 같이 npx를 글로벌하게 설치해준 다음 명령어로 똑같은 작업을 실행할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g npx</span><br><span class="line">$ npx tsc --init</span><br><span class="line">$ npx tslint --init</span><br></pre></td></tr></table></figure></p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p>(이 문단은 공식 사이트의 <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html" target="_blank" rel="noopener">TypeScript in 5 minutes</a> 를 의역한 문단입니다.)<br>이제 설정도 다 했으니 Hello world 를 작성해보자! <code>greeter.ts</code> 파일을 편집기에서 열고 다음과 같이 코드를 작성해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="string">"Jane User"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</span><br></pre></td></tr></table></figure><p>위의 코드는 그냥 평범한 자바스크립트 형식의 코드이다. 타입스크립트의 타입 시스템을 도입하여, 다음과 같이 타입을 붙여 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello "</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user: <span class="built_in">string</span> = <span class="string">"Jane User"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</span><br></pre></td></tr></table></figure><p>이제 컴파일러를 사용해보자. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tsc greeter.ts</span><br></pre></td></tr></table></figure><p>그러면 이제 <code>greeter.js</code> 라는 파일이 생성된 것을 확인할 수 있다!</p><h3 id="Interface-와-Class"><a href="#Interface-와-Class" class="headerlink" title="Interface 와 Class"></a>Interface 와 Class</h3><p>예전의 <code>greeter.ts</code> 를 타입스크립트의 특성인 인터페이스와 클래스를 이용하여 확장하여 보자. (추후 포스팅에서 다룰 내용입니다)<br><code>greeter.ts</code> 를 다음과 같이 수정하여 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">  fullName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> firstName: <span class="built_in">string</span>, <span class="keyword">public</span> middleInitial: <span class="built_in">string</span>, </span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fullName = <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;middleInitial&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span>;</span><br><span class="line">  lastName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;person.firstName&#125;</span> <span class="subst">$&#123;person.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> Student(<span class="string">"Jane"</span>, <span class="string">"M."</span>, <span class="string">"User"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = greeter(user);</span><br></pre></td></tr></table></figure><p>이제 HTML 코드를 작성하여 우리가 컴파일하여 만들 스크립트를 실행시켜 보자. 다음 파일을 <code>greeter.html</code> 이라는 이름으로 작성하고,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>TypeScript Greeter<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"greeter.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>브라우저에서 열면 처음으로 타입스크립트를 컴파일하여 만든 자바스크립트가 실행되는 것을 볼 수 있다!</p><h2 id="더-알아보면-좋은-내용들"><a href="#더-알아보면-좋은-내용들" class="headerlink" title="더 알아보면 좋은 내용들"></a>더 알아보면 좋은 내용들</h2><p>Microsoft 에서는 TypeScript로 새로운 프로젝트를 시작하는 방법 및 기존 프로젝트에서 TypeScript 로 마이그레이션(migration, 넘어가는 것. 여기서는 JS에서 TS로 변경하는 것이 되겠네요) 에 대한 가이드를 충분히 제공한다.<br>이런 가이드들은 <a href="https://www.typescriptlang.org/samples/index.html" target="_blank" rel="noopener">공식 사이트</a> 에서 확인이 가능하다.</p><p>공식 문서 또한, <a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">공식 사이트</a> 에서 확인할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근에 TypeScript 를 들여다 보면서 깨달은 내용을 적어봅니다. 첫번째는 역시나 설치와 설정이네요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/typescript.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Typescript" scheme="http://gyukebox.github.io/categories/Typescript/"/>
    
    
      <category term="Typescript" scheme="http://gyukebox.github.io/tags/Typescript/"/>
    
      <category term="Javascript" scheme="http://gyukebox.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>2017년의 나, 그리고 2018년에 되고 싶은 나</title>
    <link href="http://gyukebox.github.io/2017/12/31/2017-review/"/>
    <id>http://gyukebox.github.io/2017/12/31/2017-review/</id>
    <published>2017-12-31T06:24:54.000Z</published>
    <updated>2017-12-31T12:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>비록 지금은 저 자신을 “개발자” 라 칭하기 민망한 수준이지만, 개발자를 꿈꾸는 대학생으로써 저의 2017년 회고를 작성해보았습니다. 이 회고를 통하여 2018년에는 한층 더 성장한 모습을 볼 수 있으면 좋겠네요.</p><p><img src="/images/road.jpg" alt=""></p><a id="more"></a><p>나에게 있어 2017년을 세 문장으로 요약하자면 다음과 같이 말할 수 있겠다.</p><ul><li>아는 건 많았지만 실제로 할 줄 아는 게 없었기에, 실제로 할 줄 알려고 발버둥쳤지만,</li><li>거듭된 실패를 경험했고 한계를 경험했지만,</li><li>좋은 사람들을 많이 만난 해</li></ul><h2 id="아는-건-많았지만-실제로-할-줄-아는-건…"><a href="#아는-건-많았지만-실제로-할-줄-아는-건…" class="headerlink" title="아는 건 많았지만 실제로 할 줄 아는 건…"></a>아는 건 많았지만 실제로 할 줄 아는 건…</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python, django, flask, Django Rest Framework  </span><br><span class="line">JavaScript, TypeScript, React, Node, Progressive Web App  </span><br><span class="line">Numpy, Scipy, Pandas, Tensorflow, Keras, PyTorch  </span><br><span class="line">Serverless, AWS, CI</span><br></pre></td></tr></table></figure><p>위의 단어들은, 바로 이 글을 쓰고 있는 현재 내가 “알고 있는” 기술들이다. 내가 지금 말하는 “알고 있는” 이라 함은, “어떤 기술인지 알고, 어떤 용도로 사용되는지 안다” 라는 소리지, “사용할 줄 안다” 를 의미하는 건 결코 아니다 (이렇게 되면 절대 안 되지만).  </p><p>사실 이 글을 쓰면서 나 자신은 많이 혼나야겠다 라는 생각을 했다. 분명히 올해 초에, “깊이 있게 배우는 사람이 되어야겠다” 라고 다짐했건만, 이 글을 쓰고 있는 현재 나의 모습을 보니, “너무 깊이 없이 트렌드만 좇았구나” 라는 생각이 가장 먼저 들었기 때문이다. 과연 저 기술들 중에서 내가 자신있게, “저 이거 잘해요”. “저 이거 할 줄 알아요”. 라고 말할 수 있는 것들이 과연 한 개는 될까? 라는 질문에 나는 지금 자신있게 답을 하지 못한다.</p><blockquote><p>장고요? 알죠. 써봤죠. 할줄은 알죠.</p></blockquote><p>현재 내가 가지고 있는 기술 스택들 중에(기술 스택을 가지고 있다는 말을 하기도 민망하긴 하지만), 가장 자신있는 것을 꼽으라면 장고를 꼽을 것 같다. 하지만, 다른 개발자 분이 저에게 “어떤 개발 하세요?” 라고 물어보시면, 나는 위에 적힌 대로 대답을 할 것 같다. 사실 “할줄은 안다” 라는 말은 되게 위험한 말이라고 생각한다 - 잘 하지는 못한다는 사실을 반증하는 말이기 때문이다. 그럼에도 불구하고 저런 말을 내가 하는 이유는, 내가 기술(특히 장고) 숙련도에 대한 자신감이 턱없이 부족하기 때문이다. 왜 자신감이 부족하냐고? 말 안해도 “깊이 없이 배워서” 이다. </p><ul><li>모델을 정의하고 <code>save</code> 함수를 콜하면 데이터베이스 테이블에 row가 추가된다.</li><li>URL로 요청이 들어오면 url과 매핑된 view 함수가 불리고 템플릿이 렌더링되어 html을 만들어낸다.</li></ul><p>이런 것들은 간단히 튜토리얼 한 번만 돌면 깨닫을 수 있는 내용임에도 불구하고, 위의 내용을 이해했다고 해서 “저 장고 할 줄 알아요” 라고 말하고 다녔던 나 자신이 상당히 부끄럽다. 다행히도, 이런 점을 올해 안에 잡아서 공식 문서를 읽고, 다른 프로젝트들의 코드를 읽으면서 기술의 원리(ORM 등) 및 사용법에 깊이를 더하려고 노력을 하기는 하였다. (결과는… 잘 모르겠다. 하지만 자신감이 붙고 있는 것 같긴 하다.) </p><p>“라이브러리와 프레임워크를 배우고 사용할 때는, 적어도 왜 사용하고 사용함으로써 어떤 이득이 있는지를 알고 쓰자” 라고 기술들을 접할때 마다 다짐하지만, 편의와 간결함에 취한 나머지 다짐을 잘 못 지킨 것 같아서 안타깝다. 하지만, “무언가를 시작할 때는 공식 문서부터 살펴본다”, “이걸 사용해서 뭔가를 만들어서 제대로 이해해야겠다” 라는 마인드를 가진 이후로 계속 유지하고 있는 것 같아 다행이다.  </p><p>2017년에는 문제점을 파악했으니, 2018년에는 문제점들을 고치는 일만 남았다.</p><h2 id="2017년의-소득"><a href="#2017년의-소득" class="headerlink" title="2017년의 소득"></a>2017년의 소득</h2><p>그래도 2017년에 내가 성장을 전혀 하지 않았냐 라고 물었을 때는, “그래도 그건 아닌 것 같다” 라는 말을 할 수 있게 되었다. 2017년에 내가 경험했던 것들 중 가장 인상 깊은 것은 다음과 같이 세 가지인 것 같다.</p><h3 id="Python-JavaScript-에-빠지다"><a href="#Python-JavaScript-에-빠지다" class="headerlink" title="Python, JavaScript 에 빠지다"></a>Python, JavaScript 에 빠지다</h3><p>사실 여기서부터 나의 2017년이 시작되었다고 해도 과언이 아니다. 2016년의 나는 그냥 “에디터 켜서 코드 몇줄 치고 컴파일 하고 실행은 할 줄 아는” 전형적인 대학교 1학년이었는데, 파이썬을 접하고 부터는 실제로 서비스를 만들어 볼 시도라도 할 수 있게 되었으니까.</p><p>연초에, GDG Korea Campus 라는 커뮤니티에서 한 스터디를 같이 한 것이 인연이 됬다 <del>하지만 스터디는 잘 안됬다…</del>. 스터디에 커뮤니티에서 인지도가 높았던 한 개발자 분이 계셨고, 파이써니스타 셨다. 그 분의 깃헙 repo 랑 블로그를 염탐(?) 해보니, 파이썬이라는 언어가 엄청 매력적으로 다가왔고, “처음 시작하는 파이썬” 이라는 책으로 파이썬을 몇 줄 끄적겨러 보았더니, 파이썬의 달콤함에 푹 빠지게 되었다.</p><p>그 후에, 파이썬으로 뭔가를 만들어보기 위해서 구글을 열심히 뒤지다가, 장고라는 것을 처음 접했고, 장고의 편리함에 빠지는 것 또한 얼마 걸리지 않았다 <del>그러나 깊이를 더하는 것은 아직도 하지 못했다</del>.</p><p>JavaScript 에 손댄 계기는 두 번의 해커톤에 참여한 것이 인연이 됬다. 해커톤 참여후기에 대해서는 밑의 문단에서 더욱 자세하게 쓰겠지만, 해커톤에서 팀이 된 사람들 중에서 <strong>나만 자바스크립트를 하나도 못했었다</strong>! (사실 그게 문제가 아니었고 장고 조차도 잘 못했어서 해커톤에서 팀의 일원으로써의 역할을 제대로 수행하지 못한 것 같다) 두 번의 해커톤을 경험하고 나니, 자바스크립트를 배워보고 싶다는 생각이 들었고, 이제 막 걸음마 뗐다. </p><p>파이썬, 자바스크립트. 이 둘은 진짜 매력 넘치는 언어이고 도구인 것 같다. 2018년에는 이 두 언어에 대한 깊이를 다지는 것이 나의 목표다.</p><h3 id="첫-해커톤을-경험한-일"><a href="#첫-해커톤을-경험한-일" class="headerlink" title="첫 해커톤을 경험한 일"></a>첫 해커톤을 경험한 일</h3><p>올해 있었던 일 중에서 두 번째로 기억이 남는 것은, 바로 처음 해커톤을 참여한 일이다. 해커톤에 참여한 나는 <del>비록 해커톤에서는 병풍이었지만</del> 많은 것을 얻었는데,</p><ul><li>처음으로 상용 서비스를 만들어보았고</li><li>처음으로 다른 개발자분들이랑 디자이너 분들과 협업해 보았으며</li><li>자바스크립트 라는 언어에 눈독을 들이게 된 계기가 되었다.</li></ul><p>해커톤은 일단… 재밌었다. 밤새서 개발하는건 체력적으로는 힘들었지만 힘들었다는 생각보다는 재밌었다는 생각만 났다. (역시 나는 개발이랑 잘 맞는것 같다? <del>아직 잘 못해서 그런 거 같지만</del>)  </p><p>무엇보다 좋았던 점은 해커톤에서 만났던 사람들이 너무 좋았고, 배울 점이 많았다는 것이다. 개발을 잘 못하던 나에게 너무나도 잘 알려주셨기 때문이다. 내가 되고 싶어하는 “배워서 남 잘 주는 사람” 들을 실제로 만나서 같이 협업해 보니, 나 자신에 대한 반성도 하게 되었던 것 같다.</p><h3 id="IT-연합-동아리에-합격해서-활동하고-있는-일"><a href="#IT-연합-동아리에-합격해서-활동하고-있는-일" class="headerlink" title="IT 연합 동아리에 합격해서 활동하고 있는 일"></a>IT 연합 동아리에 합격해서 활동하고 있는 일</h3><p>하지만 무엇보다도, 올해 한 일중에서 가장 잘 했다고 생각하며, 가장 인상 깊었던 일은 바로 IT 동아리에 합격해서 활동하고 있다는 점이다.</p><blockquote><p>운영진 1 : 동아리에 오시면 한 번은 발표를 하시게 될 건데, 어떤 주제로 발표를 하시고 싶으세요?<br>나 : 저는 제가 개발해오면서 경험했던 것을 발표하고 싶어요. 예를 들면, 이렇게 하니깐 안됬는데 이러니깐 되더라? 이런 거요.<br>운영진 1 : 아, 21살의 경험?<br>나 : ……</p><p>운영진 2 : 오 이런 기술을 사용해서 서비스를 만들어 보셨네요?<br>나 : 네. 써봤죠.<br>운영진 2 : 오 그러면 이런 것들도 아시겠네요?<br>나 : (멍…)</p></blockquote><p>위의 대화는 실제로 면접 때 있었던 대화다. 분명히 내가 저런 대답을 하고 나왔을 때는 당연히 떨어지겠구나 생각했지만, 합격 메일을 받고 엄청 기뻐했었고, 동아리 재미있게 하고 있다. 무엇보다도 많은 사람을 만난다는 것이 진짜 좋았고, 나와 관심사가 비슷한 사람들과 같이 스터디 하고, 프로젝트 하는. 모든 과정이 재미있다. 사람들을 만나고 교류하고, 내가 아는 것들을(많이 없지만) 남들한테 공유할 수 있는 자리라서 애착이 가고, 열심히 참여하게 된 것 같고, 당분간 활동을 꾸준히 할 것 같다! 동아리를 함으로써 어떤 식으로 내가 성장할까도 궁금하기도 하고.</p><h2 id="개발자로써의-성장"><a href="#개발자로써의-성장" class="headerlink" title="개발자로써의 성장"></a>개발자로써의 성장</h2><p>개발자를 꿈꾸는 학생으로써, “나와 개발자로써의 성장” 에 대하여 말을 안 할수가 없을 것 같다.<br>해커톤과 커뮤니티에서 만난 개발자분들이 해주신 말씀 중에서, 가장 기억에 남는 말씀은 다음 두 가지였다.</p><blockquote><p>너무 기술들에만 매료되지 마세요. 자료구조와 알고리즘 같은 CS 기초들은 나중에 뼈와 살이 될 거에요.</p><p>전 지금 CS 기초가 너무 부족하다 생각하고, 기초 좀 잘 다질걸 이라는 후회를 해요. 기초를 탄탄하게 하세요 라는 말을 하고 싶어요.</p></blockquote><p>이런 말이 가장 기억에 남으면서 정작 나는 공부할때 깊이 없이 트렌드만 좇은 걸 보면 난 진짜 혼나야 된다. </p><ul><li>이정도면 충분하지.</li><li>이건 이미 알아. 그러니깐 넘어가고.</li><li>음 잘 모르겠다. 근데 별로 중요한 것 같지 않은데?</li></ul><p>자료구조, 알고리즘 같은 CS 기초, 그리고 언어의 기초, 마지막으로 기술의 원리. 뭔가 이론에 관련된 내용들을, 중요하다고 생각하면서도 “재미없다” 라고 치부하면서 등한시하고, “코드만 짤 줄 알면 됬지” 라는 안일함으로, 수박 겉 핥기 식으로 공부했던 2017년이었다.<br>덕분에 나는 지금 속만 파먹은 수박마냥, 아는 것은 많지만 잘하는 것은 하나도 없는 사람임에 변함이 없게 되었다. 이제 성장하려면 가장 어려울, “깊이를 더하는 일” 을 해야 한다. 깊이를 더하기 위해서 2018년에 목표로 두고 실행할 일은 다음과 같다.</p><h3 id="일일커밋"><a href="#일일커밋" class="headerlink" title="일일커밋"></a>일일커밋</h3><p>사실, 올해에 일일커밋을 시도하려고 깃허브 repo도 만들었지만, 학교 과제와 시험을 핑계삼아 하지 못했다. 분명히 과제기간, 시험기간이 아니었음에도 불구하고 따로 내가 잘하고 싶은 분야를 공부하지 않은 것에 대해서는, “그냥 내가 게을러서” 라는 말 밖에 할 말이 없다. 2018년부터는(당장 내일부터), 시험기간을 제외한 모든 날에, 적어도 2시간은 개발 공부에 투자해보고자 한다.</p><p><img src="/images/2017-contributions.png" alt="학교 과제 및 팀 프로젝트 기간을 제외하면 별다른 공부를 깊이 있게 하지 않았다고 생각되는 2017년 그래프. 과연 2018년에는 달라질 수 있을까."></p><h3 id="꾸준한-블로그-포스팅"><a href="#꾸준한-블로그-포스팅" class="headerlink" title="꾸준한 블로그 포스팅"></a>꾸준한 블로그 포스팅</h3><p>최근에(연말에), 블로그를 리모델링 하고 포스팅을 하고 있는데, 역시 공부한 것을 정리하는 데는 블로그 만한 곳이 없는 것 같다.<br>사실 포스팅 할 주제는 엄청 많다. 다 내가 안 하고 있는 것 뿐이다. 2018년에 연재하고 싶은 포스팅 주제는,</p><ul><li>입문자를 위한 장고 가이드</li><li>Django Rest Framework 가이드</li></ul><p>위 두 주제가 핵심이고, 따로 정해진 주제 없이 Python 이랑 JavaScript를 파면서 알아간 내용들을 정리하여서 포스팅을 해 보려고 한다. <strong>2주에 한 번씩은 포스팅을 하는 것</strong> 이 목표이다. 내년에 회고글을 쓸 때 즈음에는 이 블로그가 개발 포스팅으로 풍성해졌기를 바란다.</p><h3 id="프로젝트-경험-쌓기"><a href="#프로젝트-경험-쌓기" class="headerlink" title="프로젝트 경험 쌓기"></a>프로젝트 경험 쌓기</h3><p>기술을 익히고, 개발을 익히는 데에는 프로젝트 만한 것이 없다고 생각한다. 다행히 프로젝트를 할 수 있을 환경은 마련되어 있으니, 프로젝트를 하면서 “이것만은 꼭 지키고 싶다” 는 희망사항을 몇개 적어보자면,</p><ul><li>Git 커밋 메시지 이쁘게 쓰기</li><li>충분한 테스트를 통하여 내가 짠 로직에 자신감 갖기</li><li><strong>기한 꼭 지키기, 중간에 엎지 않기</strong></li></ul><p>위와 같이 3개인데, 일을 잘 벌려놓고 마무리가 흐지부지되는 나의 특성상 마무리가 잘 되었으면 좋겠다는 바람이 있다. 물론 내가 게을러 지지 않는 것이 가장 중요하지만.</p><h2 id="2018년에는-이런-사람이-되고-싶어요"><a href="#2018년에는-이런-사람이-되고-싶어요" class="headerlink" title="2018년에는 이런 사람이 되고 싶어요"></a>2018년에는 이런 사람이 되고 싶어요</h2><p>2018년에는 어떤 사람이 되고 싶어요? 라는 질문에 나는 주저없이 이렇게 답할 것이다.</p><blockquote><p>깊이 배우고, 배운 것 남 잘 주는 사람<br>“내가 할줄 아는 것들” 에 자신이 있는 사람</p></blockquote><p>위 두 문장에 부합하는 사람이 되기 위해서 갈 길이 멀다. 다시. 2017년에는 문제점을 파악했으니, 2018년에는 고치는 일만 남았다!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;비록 지금은 저 자신을 “개발자” 라 칭하기 민망한 수준이지만, 개발자를 꿈꾸는 대학생으로써 저의 2017년 회고를 작성해보았습니다. 이 회고를 통하여 2018년에는 한층 더 성장한 모습을 볼 수 있으면 좋겠네요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/road.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="블로그" scheme="http://gyukebox.github.io/categories/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
    
      <category term="블로그" scheme="http://gyukebox.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github Pages 로 블로그 만들기</title>
    <link href="http://gyukebox.github.io/2017/12/28/starting-hexo/"/>
    <id>http://gyukebox.github.io/2017/12/28/starting-hexo/</id>
    <published>2017-12-27T18:26:42.000Z</published>
    <updated>2017-12-27T18:26:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/hexo.png" alt=""></p><p>깃허브에 홈페이지를 구축할 수 있다는 사실을 아시나요?<br><a href="">GitHub Pages</a> 를 활용하면, 깃허브에 홈페이지를 구축할 수 있는데요, 홈페이지를 구축할 때 필요한 HTML 과 CSS 파일들을 만들어 주는 작업을 하는 도구 중 하나가 Hexo 입니다.<br>이번에는 Hexo 를 사용하여, GitHub Pages 에 블로그를 구축하는 방법에 대하여 알아보도록 하겠습니다!</p><a id="more"></a><h2 id="Hexo-란"><a href="#Hexo-란" class="headerlink" title="Hexo 란?"></a>Hexo 란?</h2><p>Hexo 는 JavaScript 기반의 <strong>정적 페이지 생성기(Static Page Generator)</strong>입니다.<br>자바스크립트 기반이기 때문에, 웹(특히 프론트엔드) 개발자들에게 인기가 많으며, 무려 <strong>19832개의 깃허브 스타</strong>를 받았는데요, 정적 페이지 생성기 중에서는 <strong>3위</strong>에 해당하는 수입니다!<br>또한, 한국어로 문서화가 엄청 잘 되어 있어서 시작하기도 쉽습니다.</p><p>(정적사이트 생성기 스타수 1위는 지킬(jekyll), 2위는 휴고(hugo) 입니다. 각각 루비와 고 언어 기반입니다.)</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>Hexo 를 설치하는 방법은 간단합니다.<br>Hexo 는 JavaScript 기반이므로, Node.js 런타임 환경이 필요합니다. 또한, 깃허브 페이지를 사용하므로 당연히 git 도 설치가 되어 있어야 합니다.<br>Node.js 및 git 설치 방법은 링크로 대체하도록 하겠습니다.</p><ul><li><a href="https://nodejs.org/ko/download/" target="_blank" rel="noopener">Node.js 설치</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git 설치</a></li></ul><p>(혹시 git 이 처음이시라면, 제가 예전에 쓴 <a href="https://gyukebox.github.io/2017/08/10/git/">Git 사용법</a>에 대한 글이 있는데, 한번 읽고 오시는 걸 추천드려요!)</p><p>Node.js 와 git 설치를 완료하셨다면, 이제 hexo 를 사용할 준비가 다 되었습니다!<br>우선, 먼저 hexo client 를 설치하도록 하겠습니다. 다음 명령어로 설치해주세요.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>(참고) 제 환경은 이렇게 생겼습니다:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo: 3.4.4</span><br><span class="line">hexo-cli: 1.0.4</span><br><span class="line">os: Darwin 16.7.0 darwin x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 8.4.0</span><br><span class="line">v8: 6.0.286.52</span><br><span class="line">uv: 1.13.1</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 57</span><br><span class="line">nghttp2: 1.22.0</span><br><span class="line">openssl: 1.0.2l</span><br><span class="line">icu: 59.1</span><br><span class="line">unicode: 9.0</span><br><span class="line">cldr: 31.0.1</span><br><span class="line">tz: 2017b</span><br></pre></td></tr></table></figure></p><h2 id="시작하기"><a href="#시작하기" class="headerlink" title="시작하기"></a>시작하기</h2><p>좋습니다. 이제 블로그를 위한 디렉토리(폴더) 를 만들 준비가 되었습니다!<br>다음 명령어로 블로그를 생성해주시고, 해당 디렉토리로 이동해주세요.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init my-blog</span><br><span class="line">$ cd my-blog</span><br></pre></td></tr></table></figure><p>그 다음, 로컬 서버를 실행해 봅시다! (뒤에서 자세히 다루겠지만) 다음 명령어로 서버를 실행해 보세요!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>이제 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 으로 들어가봅시다. 어떤가요, Hello World 페이지가 이쁘게 잘 생성되었나요?</p><h2 id="기본-설정"><a href="#기본-설정" class="headerlink" title="기본 설정"></a>기본 설정</h2><p>좋아요. 이제 이 페이지를 나만의 것으로, 더 이쁘게 꾸밀 일만 남았습니다. 그러기 위해서는 그 전에 설정을 해줘야겠죠?<br>현재 프로젝트 폴더의 구조는 다음과 같을 것입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">my-blog</span><br><span class="line">├── README.md</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">│   └── _posts</span><br><span class="line">│       └── hello-world.md</span><br><span class="line">|</span><br><span class="line">├── themes</span><br><span class="line">│   └── landscape</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure></p><p>여기서, <code>_config.yml</code> 파일을 열어줍시다.</p><p>설정 가능한 항목이 엄청 많은데요, 그 중 주된 설정들을 살펴보면,</p><p><code>title</code> : 사이트의 제목입니다.<br><code>subtitle</code> : 사이트의 부제목 입니다.<br><code>author</code> : 작가입니다. 여러분의 이름을 써줍시다.<br><code>language</code> : 우리는 한국어를 사용하니깐 <code>ko</code> 를 써줍시다. 영어를 기본값으로 하시려면 <code>en</code> 을 써주시면 됩니다.</p><p>현재 우리가 건드릴 수 있을만한 설정은 이 정도입니다. 다 설정하셨다면, 브라우저를 새로고침해봅시다.<br>어떤가요, 사이트의 제목이 바뀌었나요? 언어는요?</p><h2 id="글쓰기"><a href="#글쓰기" class="headerlink" title="글쓰기"></a>글쓰기</h2><p>이제 첫 포스팅을 해 보도록 합시다! 포스트는 다음 명령어를 입력하여서 생성할 수 있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post &lt;post-name&gt;</span><br></pre></td></tr></table></figure></p><p>무슨 일이 일어났나요? <code>source/_posts</code> 폴더에 <code>&lt;post_name&gt;.md</code> 라는 이름의 마크다운 파일이 새로 생성되었습니다. 그리고, 해당 파일을 열어다 보시면, 일정 형식의 헤더가 삽입되어 있는 모습을 보실 수가 있으실 거에요. 이런 식으로요.</p><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Title</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="string">/12/28</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>이런 헤더를 hexo 에서는 <code>front-matter</code> 이라고 합니다. 해당 포스트에 대한 설정이라고 생각하시면 됩니다. 위의 예시의 경우를 살펴보면,</p><p><code>title</code> : 우리의 포스트 제목입니다<br><code>date</code> : 우리의 포스트가 생성된 날짜입니다. 자동으로 생성됩니다.<br><code>tags</code> : 태그를 삽입할 수 있습니다. 태그는,<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Foo</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Bar</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Baz</span></span><br></pre></td></tr></table></figure></p><p>이런 식으로 삽입하실 수 있습니다. 순서에는 상관이 없습니다.</p><p>위의 예시에는 나와있지 않지만, </p><p><code>categories</code> : 카테고리를 설정할 수 있습니다. 카테고리는,<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Foo</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Bar</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Baz</span></span><br></pre></td></tr></table></figure></p><p>이런 식으로 삽입하실 수 있는데, <code>Foo/Bar/Baz</code> 형태의, 순차적인 형태를 가지게 됩니다. 따라서 순서가 매우 중요합니다.<br><code>layout</code> : 해당 페이지의 레이아웃입니다.<br>보통 <code>page</code>, <code>post</code>, <code>draft</code> 중 하나의 값을 가지게 되며, <code>scaffolds</code> 폴더 안의 파일 이름이면 어떤 것이든지 들어갈 수 있습니다.<br><code>layout</code> 의 값을 <code>false</code> 로 설정하게 되면, 해당 포스트는 처리되지 않습니다.<br><code>layout</code> 의 값을 설정하지 않으면, <code>_config.yml</code> 의 <code>default_layout</code> 값을 참조하게 됩니다.</p><h3 id="본문-작성하기"><a href="#본문-작성하기" class="headerlink" title="본문 작성하기"></a>본문 작성하기</h3><p>이제, 포스트에 대한 환경설정이 끝났으니, 글을 쓸 일만 남았네요!<br>Hexo 는 markdown 문법을 지원하므로, 마크다운 문법을 사용하여 포스트를 작성하시면 아주 편합니다. 마크다운 문법에 관해서는 <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="noopener">링크</a> 로 대체하도록 하겠습니다.</p><h3 id="Drafts"><a href="#Drafts" class="headerlink" title="Drafts"></a>Drafts</h3><p>Hexo 에는 미 완성된 포스트를 보관하고, 실제 사이트에는 반영하지 않게 할 수 있는 drafts 라는 기능이 있습니다. Drafts 는 <code>sourct/_drafts</code> 폴더에 따로 관리된다는 차이점만 있을 뿐, <code>_posts</code> 안의 실제 포스트와 형식 면에서는 차이가 거의 없습니다. 하나, <code>date</code> 만 없네요.</p><p>다음 명령어를 사용하면 draft 를 만드실 수 있습니다:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft &lt;post-name&gt;</span><br></pre></td></tr></table></figure></p><p><code>sourct/_drafts</code> 폴더를 보시면 <code>&lt;post_name&gt;.md</code> 라는 파일이 생성되어 있는 것을 보실 수가 있습니다.<br>포스트 작성이 끝난 후, <code>date</code> 속성을 추가해주고, <code>_posts</code> 폴더로 옮겨주면 포스트가 되지만, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish &lt;post-name&gt;</span><br></pre></td></tr></table></figure><p>위의 명령어를 사용하시면 자동으로 draft 를 post 로 만들어줍니다!</p><h2 id="배포"><a href="#배포" class="headerlink" title="배포"></a>배포</h2><p>포스트를 다 작성하였고, 로컬 서버에서 정상적으로 표시되는 것을 확인하였다면, 실제 사이트에 올리는 일만 남았겠죠?<br>이 과정을 배포(deploy) 라고 하는데, 실제로 배포하기 전에 해야 할 일들이 몇 가지 있습니다.</p><h3 id="Github-Repository-생성"><a href="#Github-Repository-생성" class="headerlink" title="Github Repository 생성"></a>Github Repository 생성</h3><p>첫 번째는, 깃허브 저장소를 생성하는 일입니다.<br>아래 사진과 같이, 저장소 이름을 <strong><code>&lt;username&gt;.github.io</code></strong> 로 만들어주세요!<br><img src="/images/new_repository.png" alt=""></p><h3 id="배포-설정하기"><a href="#배포-설정하기" class="headerlink" title="배포 설정하기"></a>배포 설정하기</h3><p>Create Repository 를 누르셨다면, 다시 <code>_config.yml</code> 파일로 돌아가서 배포 설정을 건드려 보도록 합시다.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/&lt;username&gt;/&lt;username&gt;.github.io</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  message:</span></span><br></pre></td></tr></table></figure></p><p>맨 밑의 <code>deploy</code> 란을 다음과 같이 작성하신 후,</p><h3 id="파일-생성하기"><a href="#파일-생성하기" class="headerlink" title="파일 생성하기"></a>파일 생성하기</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>위의 명령어로 배포 파일들을 생성해 줍시다!<br><code>public</code> 폴더가 새로 생성된 것을 확인하실 수 있는데, 해당 폴더가 깃허브 저장소에 올라가며, 해당 폴더에는 마크다운으로 작성한 포스트의 HTML, 그리고 테마의 CSS와 자바스크립트가 들어있습니다.</p><h3 id="배포하기"><a href="#배포하기" class="headerlink" title="배포하기"></a>배포하기</h3><p>배포 파일 생성까지 다 하셨다면, hexo 를 github 에다 배포할 수 있는 도구를 설치하셔야 하는데,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>위의 명령어로 설치하실 수 있습니다. 설치하셨다면, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>위의 명령어 하나면 배포가 완료됩니다!</p><p>설정은 이미 한번 하셨으므로,<br><code>generate</code> 후 <code>deploy</code> 명령어를 입력하시면 언제든지 사이트를 배포할 수 있습니다.</p><p>이제, <a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a> 로 들어가봅시다. 사이트가 잘 생성되어 있나요?</p><h2 id="더-알아볼-내용들"><a href="#더-알아볼-내용들" class="headerlink" title="더 알아볼 내용들"></a>더 알아볼 내용들</h2><p>이번 포스트에서는 간단한 과정만 다뤘던 지라, hexo 의 더욱 매력적인 feature 들은 아쉽지만, 건너뛰었습니다.<br>Hexo의 모든 기능들은 <a href="https://hexo.io/ko/docs/" target="_blank" rel="noopener">공식 문서</a>에서 확인하실 수 있습니다.<br>추후 포스팅에서 다루어 볼 내용들은, </p><ul><li>테마 설정하는 법</li><li>사이트 구조 커스터마이징 하는 법</li><li>플러그인 사용하는 법</li></ul><p>등이 있겠네요!</p><p>이번 포스팅에서는 github pages 가 무엇인지, hexo 가 무엇인지에 관해서 짤막하게 알아보았고, hexo 를 활용하여 블로그를 만드는 방법을 알아보았습니다.<br>역시 개발자라면, 블로그죠! Happy blogging!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/hexo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;깃허브에 홈페이지를 구축할 수 있다는 사실을 아시나요?&lt;br&gt;&lt;a href=&quot;&quot;&gt;GitHub Pages&lt;/a&gt; 를 활용하면, 깃허브에 홈페이지를 구축할 수 있는데요, 홈페이지를 구축할 때 필요한 HTML 과 CSS 파일들을 만들어 주는 작업을 하는 도구 중 하나가 Hexo 입니다.&lt;br&gt;이번에는 Hexo 를 사용하여, GitHub Pages 에 블로그를 구축하는 방법에 대하여 알아보도록 하겠습니다!&lt;/p&gt;
    
    </summary>
    
      <category term="블로그" scheme="http://gyukebox.github.io/categories/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
    
      <category term="블로그" scheme="http://gyukebox.github.io/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"/>
    
      <category term="git" scheme="http://gyukebox.github.io/tags/git/"/>
    
      <category term="Hexo" scheme="http://gyukebox.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="http://gyukebox.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Django 2.0 의 주 변경사항 살펴보기!</title>
    <link href="http://gyukebox.github.io/2017/12/27/django-2.0-url/"/>
    <id>http://gyukebox.github.io/2017/12/27/django-2.0-url/</id>
    <published>2017-12-26T15:00:00.000Z</published>
    <updated>2017-12-26T21:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br>    <img src="/images/django.png"><br></div><p>Django 2.0 이 릴리즈 되었습니다! 1.11 버전과 비교해 다른 주요 상황들을 살펴봄과 동시에, 2.0에서만 지원하는 핵심 기능들을 소개합니다!</p><a id="more"></a> <p><code>Django</code> 2.0 이 12 월 2 일 자로 정식 출시 되었습니다! <del>그런데 왜 포스팅은 12 월 27 일?</del><br>써본 결과, 확실히 1.11 버전 보다 편해진 점이 많은 것 같은데, 이전 버전과 비교함과 동시에 2.0 버전의 핵심 기능을 소개하고자 해당 포스팅을 준비하게 되었습니다.</p><h2 id="호환되는-Python-버전"><a href="#호환되는-Python-버전" class="headerlink" title="호환되는 Python 버전"></a>호환되는 Python 버전</h2><p>Django 2.0 은 파이썬 3.4, 3.5, 3.6 과 호환됩니다(현재 가장 최신 파이썬 버전은 3.6.4 입니다).<br>네 그렇습니다. <strong>파이썬 2 의 지원을 django 2.0 에서는 공식적으로 중단</strong>하게 된 것입니다! (아마 1.11 에서 2.0 으로 버전이 뛴 큰 원인 중 하나인 것 같습니다)</p><p>또한, 파이썬 3.4 를 지원하는 마지막 버전이라고 합니다. 또한, 2019 년 3 월까지만 파이썬 3.4 를 지원 할 예정이라고 하므로, 파이썬 3.4 버전을 배포하려고 하시는 분들은 1.11 버전에 머물러 게시는 게 좋다고 합니다(2020 년 4 월까지 지원 예정).</p><p>구 파이썬 버전에 대한 내용을 <a href="https://docs.djangoproject.com/en/2.0/releases/2.0/#python-compatibility" target="_blank" rel="noopener">Django 공식 문서</a>에서 발췌하였습니다.</p><blockquote><p>The Django 1.11.x series is the last to support Python 2.7.</p><p>Django 2.0 will be the last release series to support Python 3.4. If you plan a deployment of Python 3.4 beyond the end-of-life for Django 2.0 (April 2019), stick with Django 1.11 LTS (supported until April 2020) instead. Note, however, that the end-of-life for Python 3.4 is March 2019.</p></blockquote><p>(얼른 파이썬 3 으로 넘어오세요!)<br>이제부터는 장고 2.0 의 주요 변경사항을 살펴보도록 하겠습니다!</p><h2 id="URL-패턴의-단순화"><a href="#URL-패턴의-단순화" class="headerlink" title="URL 패턴의 단순화"></a>URL 패턴의 단순화</h2><p>(아마 거의 모든 분들이 같은 생각이시겠지만) 장고 2.0 을 쓰면서 가장 편해졌다고 느낀 변경사항이 아닐 까 합니다!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$'</span>, views.year_archive),</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>위 예시처럼 정규표현식을 사용해야 했던 url 을,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/'</span>, views.year_archive),</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>다음과 같이 간단하게, 훨씬 쉽게 사용할 수 있습니다!<br>변경 사항을 살펴보면,</p><ul><li>기존 <code>django.conf.urls</code> 모듈에 있던 url 관련 함수들은, <code>django.urls</code> 로 옮겨졌습니다.</li><li><code>django.conf.urls.url()</code> 대신, <code>django.urls.path()</code> 함수를 사용할 수 있습니다!</li><li><code>include()</code> 함수 또한 <code>django.urls</code> 로 옮겨졌습니다.</li></ul><p>이 정도입니다.<br>기존 정규식을 사용한 url 표현을 하지 못하는 것은 아닙니다. <code>django.urls.re_path()</code> 함수를 사용하시면 여전히,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re_path(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$'</span>, views.year_archive),</span><br></pre></td></tr></table></figure><p>다음과 같이 정규식을 사용하실 수 있습니다.</p><p>개인적인 의견) 기존에 정규식을 많이 사용해보신 분들이라면 <code>re_path</code> 가 편하실 수 있다고 생각합니다. 하지만, 가독성 부분에서는 새로운 방식인 <code>path</code> 를 사용하는 것이 더 낫다고 생각합니다.</p><h2 id="더욱-친화적으로-변한-모바일-admin-사이트"><a href="#더욱-친화적으로-변한-모바일-admin-사이트" class="headerlink" title="더욱 친화적으로 변한 모바일 admin 사이트"></a>더욱 친화적으로 변한 모바일 <code>admin</code> 사이트</h2><p>모바일 관리자 페이지가 반응형으로 바뀌었습니다!</p><table><thead><tr><th style="text-align:center">아이폰 화면</th><th style="text-align:center">안드로이드 화면</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/images/django-admin-mobile-iphone.png" alt=""></td><td style="text-align:center"><img src="/images/django-admin-mobile-android.png" alt=""></td></tr></tbody></table><h2 id="새로-생긴-사항-요약"><a href="#새로-생긴-사항-요약" class="headerlink" title="새로 생긴 사항 요약"></a>새로 생긴 사항 요약</h2><p>지금까지는 장고 2.0 에서 새로 생긴 사항들을 살펴보았습니다. 간단하게 요약하자면,</p><ul><li>파이썬 2.7 버전의 지원이 공식적으로 중단되었다.</li><li>정규표현식을 사용하지 않는, 간단한 url 매핑이 가능해졌다.</li><li><code>admin</code> 페이지가 반응형으로, 이쁘게 변하였다.</li></ul><p>이 정도 되겠습니다.</p><h2 id="삭제된-사항들"><a href="#삭제된-사항들" class="headerlink" title="삭제된 사항들"></a>삭제된 사항들</h2><p>지금부터는 2.0 으로 오면서 삭제된 사항들을 살펴보도록 하겠습니다.</p><h3 id="bytestring-에-대한-지원-일부-삭제"><a href="#bytestring-에-대한-지원-일부-삭제" class="headerlink" title="bytestring 에 대한 지원 일부 삭제"></a><code>bytestring</code> 에 대한 지원 일부 삭제</h3><p>파이썬 2 에 대한 지원 중단과 동시에, <code>bytestring</code> 에 대한 지원도 일부 삭제되었습니다. (예시: <code>reverse()</code> 함수는 <code>force_text()</code> 대신에 <code>str()</code> 함수를 사용합니다)</p><p>파이썬 3 에서의 모든 문자열은 <strong>유니코드</strong> 입니다! (파이썬 2 에서는 바이트) 바이트를 계속 사용하고 싶으시다면, <code>bytes</code> 타입을 사용하셔야 할 것입니다.<br>이제 <code>b&#39;some text&#39;</code>는 , <code>&quot;b&#39;some_text&quot;</code> 처럼 읽혀질 것입니다.</p><h3 id="오라클-11-2-에-대한-지원-중단"><a href="#오라클-11-2-에-대한-지원-중단" class="headerlink" title="오라클 11.2 에 대한 지원 중단"></a>오라클 11.2 에 대한 지원 중단</h3><p>오라클 데이터베이스 11.2 버전에 대한 지원이 중단되었습니다. (가장 최신 버전은 12.x)</p><h2 id="Last-but-not-least…"><a href="#Last-but-not-least…" class="headerlink" title="Last, but not least…"></a>Last, but not least…</h2><p>처음 장고 어플리케이션을 만들고 서버를 실행하면,<br><img src="/images/django-at-start.png" alt=""></p><p>기존에, It works! 문구가 사라지고, 다음과 같이 예쁜 시작 화면이 나오네요!</p><h2 id="기타-변경사항"><a href="#기타-변경사항" class="headerlink" title="기타 변경사항"></a>기타 변경사항</h2><p>기타 변경사항은 <a href="https://docs.djangoproject.com/en/2.0/releases/2.0/" target="_blank" rel="noopener">장고 2.0 공식 릴리즈 문서</a> 에서 확인하실 수 있습니다.</p><p>이번 포스트에서는 간단하게, 장고 2.0 이 출시되면서 기존의 장고와 비교하여 달라진 점을 살펴보았습니다. 개인적인 한줄 요약은, “초보자가 사용하기 편해진 것 같다” 입니다. (URL 매핑 변화가 이걸?)</p><p>+) 시일 내에, 장고 입문 시리즈를 연재할 계획입니다. 많이 봐주시면 감사하겠습니다! :D</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;    &lt;img src=&quot;/images/django.png&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;Django 2.0 이 릴리즈 되었습니다! 1.11 버전과 비교해 다른 주요 상황들을 살펴봄과 동시에, 2.0에서만 지원하는 핵심 기능들을 소개합니다!&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyukebox.github.io/categories/Python/"/>
    
      <category term="Django" scheme="http://gyukebox.github.io/categories/Python/Django/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
      <category term="Django" scheme="http://gyukebox.github.io/tags/Django/"/>
    
      <category term="Web" scheme="http://gyukebox.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Python 함수의 docstring 과 decorator</title>
    <link href="http://gyukebox.github.io/2017/10/03/docstring_decorator/"/>
    <id>http://gyukebox.github.io/2017/10/03/docstring_decorator/</id>
    <published>2017-10-02T15:00:00.000Z</published>
    <updated>2017-12-26T21:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/python.png" alt=""></p><p>파이썬의 함수는 엄청 강력합니다. 파이썬의 함수의 강력함을 배가시켜주는 두 요소, docstring과 decorator에 대한 소개입니다.</p><a id="more"></a><p>이번 포스팅은, 파이썬의 함수 중 함수를 서식하는 기능을 하는 <code>docstring</code>과 <code>decorator</code>에 관한 내용이다. 특히 데코레이터 같은 경우에는 처음 접하는 경우에는 “저게 뭐지?” 하고 느낄 수 있지만, 잘 사용하면 매우 강력한 도구가 되는 만큼 잘 알고 가는 것이 좋다.<br>(이번 포스팅에서는 함수에 적용되는 데코레이터만 다룹니다. 클래스를 데코레이터로 만들 수도 있어요, 하지만 여기서는 다루지 않고 오로지 함수에만! 집중해 보겠습니다.)</p><h2 id="Docstring"><a href="#Docstring" class="headerlink" title="Docstring"></a>Docstring</h2><p>함수가 어떤 일을 하는지에 대한 설명은 보통 코드 내에서는 주석으로 쓰고, 외부에서는 wiki 페이지를 이용한다던가 해서 문서화시켜서 정리하곤 한다. 하지만, 파이썬에서는, 함수에 대한 설명을 함수 내에 넣을 수 있는 기능이 있는데, 그게 바로 <code>docstring</code> 이다.</p><p>일단 코드를 살펴보자</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">piglatin</span><span class="params">(word)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param word: word that would be changed into piglatin</span></span><br><span class="line"><span class="string">    :return: piglatin version of word</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> word[<span class="number">1</span>:] + word[<span class="number">0</span>] + <span class="string">'ay'</span></span><br></pre></td></tr></table></figure><p>눈치챘겠지만, docstring 은 document string 을 줄인 말이다. 위의 코드와 같이 함수 시작 부분에 큰따옴표 3 개를 연달아 붙임으로써 docstring 을 정의할 수 있다.</p><p>함수의 docstring 을 출력하고 싶으면 다음과 같이 하면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>piglatin(<span class="string">'word'</span>)</span><br><span class="line"><span class="string">'ordway'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(piglatin)</span><br><span class="line">Help on function piglatin <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">piglatin(word)</span><br><span class="line">    :param word: word that would be changed into piglatin</span><br><span class="line">    :<span class="keyword">return</span>: piglatin version of word</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(piglatin.__doc__)</span><br><span class="line"></span><br><span class="line">    :param word: word that would be changed into piglatin</span><br><span class="line">    :<span class="keyword">return</span>: piglatin version of word</span><br></pre></td></tr></table></figure><p><code>help</code> 함수를 활용하면 함수의 docstring 을 출력할 수 있다. 위와 같이 서식이 갖추어져서 나온다.<br>또한, 서식 없이 docstring 을 있는 그대로 보고 싶으면, 함수의 <code>__doc__</code> 필드를 출력하면 된다.</p><h3 id="함수에-필드가-있다"><a href="#함수에-필드가-있다" class="headerlink" title="함수에 필드가 있다?"></a>함수에 필드가 있다?</h3><p>사실 docstring 은 간단한 주석이 아니라, 함수의 여러가지 필드(변수) 중 <code>__doc__</code> 변수에 들어간다 (<code>__doc__</code> 필드는 docstring 을 위하여 만들어졌다). 함수에도 여러가지 변수가 있는데(위의 <code>__doc__</code> 과 함수 이름이 저장되는 <code>__name__</code> 이 대표적이다), 왜냐하면 함수도 하나의 클래스이기 때문이다!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(piglatin)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><p>데코레이터, 이름을 딱 보고 무언가를 꾸며주는 것이구나 라고 생각했다면 그게 바로 정답이다! 데코레이터는 기존의 코드에 여러가지 추가 기능을 적용시키는 파이썬의 한 문법인데, <strong>주로 함수의 형태로 많이 쓰인다</strong>.</p><p>데코레이터를 보다 잘 알기 위해서는 <a href="http://www.gyuveloper.com/post?6" target="_blank" rel="noopener">일급 객체</a>가 무엇인지, 그리고 파이썬의 함수가 왜 일급 객체인지를 이해하고 있어야 한다. 만약 일급 객체라는 단어가 생소하거나, 파이썬 함수가 왜 일급 객체인지 아리송하다면 해당 내용을 먼저 보고 오는 것을 추천드린다.</p><p>가장 좋은 방법은 역시 눈으로 보고 이해하는 것. 다음 코드를 함께 살펴보자.<br>(파일 이름을 <code>decorator.py</code> 라고 하겠다)</p><h3 id="데코레이터-함수의-일반적인-형식-그리고-특징"><a href="#데코레이터-함수의-일반적인-형식-그리고-특징" class="headerlink" title="데코레이터 함수의 일반적인 형식, 그리고 특징"></a>데코레이터 함수의 일반적인 형식, 그리고 특징</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">document_it</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Running function:'</span>, func.__name__)</span><br><span class="line">        print(<span class="string">'Positional arguments:'</span>, args)</span><br><span class="line">        print(<span class="string">'Keyword arguments:'</span>, kwargs)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Result:'</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> new_function</span><br></pre></td></tr></table></figure><p>(<code>document_it</code> 함수를 잘 살펴보면, <strong>매개변수도 함수이고, 반환값도 함수</strong>인 것을 눈치챌 수 있는데, <strong>파이썬의 함수는 일급 객체임을 단편적으로 보여주는 예시가 된다</strong>.)</p><p><code>document_it</code> 과 같은 형태를 가지는 함수를 <strong>데코레이터 함수</strong>라고 부르는데, 데코레이터 함수의 특징을 살펴보면,</p><ul><li>함수를 매개변수로 받는다(위의 예제에서는 <code>func</code>). 해당 함수는 데코레이터가 적용되는 대상이 된다.</li><li>데코레이터 함수 내에서 내부 함수가 정의되고, 정의한 내부 함수를 리턴한다. 데코레이터 함수에 인자로 넘어온 함수를, <strong>내부 함수가 꾸며주게 된다</strong>.</li></ul><p>한 문장으로 위의 예시를 들어서 요약하면, <strong><code>func</code>을 <code>new_function</code>이 꾸며준다!</strong></p><p>위의 <code>document_it</code>의 경우에는 어떻게 될까? <code>new_function</code> 을 살펴보면 함수에 대한 정보들을 출력해주고, 함수를 실행한 후 결과를 리턴하는데, 아마도 <code>func</code> 에 대한 정보를 출력해준 다음 <code>func</code> 을 실행한 결과를 리턴하게 되겠구나 라는 것을 예상할 수 있다.</p><h3 id="수동으로-데코레이터-붙이기"><a href="#수동으로-데코레이터-붙이기" class="headerlink" title="수동으로 데코레이터 붙이기"></a>수동으로 데코레이터 붙이기</h3><p>데코레이터를 적용시켜보면,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_ints(3, 5) = 8</span></span><br><span class="line">decorated_add_ints = document_it(add_ints)</span><br><span class="line">print(decorated_add_ints(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>위와 같이 두 정수를 더하는 <code>add_ints</code> 에 <code>document_it</code> 데코레이터 함수를 붙여서, <code>decorated_add_ints</code> 변수에 저장하였다(함수를 변수에 저장할 수 있는건 파이썬에서 함수는 일급 객체니까!). <code>decoreated_add_ints</code> 에 3 과 5 를 넣어서 실행해보면, <code>add_ints</code> 에 대한 정보가 쭉 나오고, 결괏값인 8 이 출력될 것임을 예상할 수 있는데,<br>아니나 다를까, 실행 결과는,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python decorator.py</span><br><span class="line">Running function: add_ints</span><br><span class="line">Positional arguments: (3, 5)</span><br><span class="line">Keyword arguments: &#123;&#125;</span><br><span class="line">Result: 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>만약 그냥 <code>add_ints</code> 만 호출했다면 그냥 8 이 리턴되었겠지만, <code>document_it</code> 데코레이터 함수를 붙여서 실행하면 위와 같이 <strong>추가로 기능이 붙어서 실행된다</strong>.</p><p>아마 눈치 빠른 사람들은 알아챘겠지만, <strong>추가 기능을 붙이기 위해서 원래 함수를 수정하지 않아도 된다는 점</strong> 이 데코레이터의 제일 큰 장점 중 하나이다! 현실적인 예시를 들어보자. 함수를 디버깅하기 위해서 함수 내에 전달된 인자의 변화를 관찰하고 싶을 때, <code>print</code> 문을 추가하면 쉽게 볼 수 있지만, 원래 함수를 수정해야 하는 불편함이 있다. 이 때, <code>print</code> 문으로 함수의 인자를 출력하게 해주는 데코레이터 함수를 작성하여 붙인다면, 원함수의 수정 없이 더욱 편리하게 디버깅을 할 수 있다.</p><h3 id="보다-편리한-데코레이터-사용법"><a href="#보다-편리한-데코레이터-사용법" class="headerlink" title="보다 편리한 데코레이터 사용법"></a>보다 편리한 데코레이터 사용법</h3><p>위의 예제에서는 수동으로 데코레이터를 붙이는 방법을 살펴보았는데, 이번에는 보다 편리하게 데코레이터를 함수에 사용해보자. <code>decorator.py</code>의 <code>add_ints</code> 와 그 밑의 부분을 다음과 같이 수정해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@document_it</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">print(add_ints(<span class="number">5</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>수동으로 데코레이터 함수를 붙이는 부분이 없어진 대신에, <code>add_ints</code> 위에 한 줄이 추가되었다.<br>그렇다, <code>@decorator_function</code> 을 사용하면, 함수에 데코레이터 함수를 붙일 수 있다. 위의 예제에서는 <code>add_ints</code> 함수에 <code>document_it</code> 데코레이터 함수가 자동으로 붙게 된다. 따라서, <code>add_ints</code> 함수를 그냥 실행해도,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python decorator.py</span><br><span class="line">Running function: add_ints</span><br><span class="line">Positional arguments: (5, 4)</span><br><span class="line">Keyword arguments: &#123;&#125;</span><br><span class="line">Result: 9</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>위와 같이 데코레이터가 적용된 모습을 확인할 수 있다!</p><h3 id="두-개-이상의-데코레이터"><a href="#두-개-이상의-데코레이터" class="headerlink" title="두 개 이상의 데코레이터"></a>두 개 이상의 데코레이터</h3><p>만약 <code>decorator_py</code>에서 <code>add_ints</code>의 결과를 제곱하는 기능을 추가하고 싶다고 하면 어떻게 될까? 물론 <code>add_ints</code>를 수정할 수도 있겠지만, 데코레이터를 이용하여 수정 없이 기능을 추가하여 보자.</p><p><code>decorator_py</code> 에 다음과 같은 수정을 가해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_it</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result * result</span><br><span class="line">    <span class="keyword">return</span> new_function</span><br><span class="line"></span><br><span class="line"><span class="meta">@document_it</span></span><br><span class="line"><span class="meta">@square_it</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br></pre></td></tr></table></figure><p>한 번 봤으니 두 번은 어렵지 않다. <code>square_result</code> 는 데코레이터 함수이고, <code>add_ints</code> 에 두 개의 데코레이터를 붙인 경우이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python decorator.py</span><br><span class="line">Running function: add_ints</span><br><span class="line">Positional arguments: (5, 4)</span><br><span class="line">Keyword arguments: &#123;&#125;</span><br><span class="line">Result: 81</span><br><span class="line">81</span><br></pre></td></tr></table></figure><p>어, 실행 결과는 예상했던 것과는 살짝 다르다. <code>add_ints</code> 의 실행 결과는 9 지만, 이를 제곱하여 출력하고 싶어서 <code>square_it</code> 데코레이터를 붙였는데, <code>add_ints</code> 의 결과 자체가 81 이 되어버렸다! 이유는 바로 <strong>데코레이터의 실행 순서</strong> 에 있다. 함수에 2 개 이상의 데코레이터가 붙은 경우, <strong>함수 바로 위에 붙은 데코레이터부터(def 바로 위) 역순으로 실행된다</strong>. 위의 경우에는, <code>square_it</code> 데코레이터가 먼저 실행된 후, <code>document_it</code> 데코레이터가 실행되었으므로, <code>add_ints</code> 의 결과 자체가 81 로 바뀌어버린 것이다.</p><p>그렇다면, 두 데코레이터의 실행순서를 바꿔주면…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@square_it</span></span><br><span class="line"><span class="meta">@document_it</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python decorator.py</span><br><span class="line">Running function: add_ints</span><br><span class="line">Positional arguments: (5, 4)</span><br><span class="line">Keyword arguments: &#123;&#125;</span><br><span class="line">Result: 9</span><br><span class="line">81</span><br></pre></td></tr></table></figure><p>우리가 원했던 그림이 나왔다!</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>이번 포스팅의 내용을 간추려보면,</p><ul><li><code>docstring</code> 은 함수 내부에 설명을 추가한 문자열이고, 함수의 <code>__doc__</code> 변수에 저장된다.</li><li>Docstring 에 관한 컨벤션 - <a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP 257</a></li><li><code>decorator</code> 은 함수에 붙어서, 붙여진 함수를 꾸며주는 역할을 한다.</li><li>데코레이터 함수의 기본 형식은,</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_function</span><span class="params">(original_function)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_function</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="comment"># YOUR_CODE_HERE</span></span><br><span class="line">    <span class="keyword">return</span> wrapper_function</span><br></pre></td></tr></table></figure><p>이다. <code>original_function</code>에 <code>wrapper_function</code> 의 기능을 덧붙여준다.</p><ul><li>함수에 두 개 이상의 데코레이터가 붙은 경우, 함수에서 가까운 데코레이터부터 차례대로 실행된다.</li><li>Decorator 에 관한 컨벤션 - <a href="https://www.python.org/dev/peps/pep-0318/" target="_blank" rel="noopener">PEP 318</a></li></ul><p>이제 <code>docstring</code>을 이용하여 함수에 쉽게 주석을 달고, <code>decorator</code>을 이용하여 함수에 추가 기능들을 덧붙여보자!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/python.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;파이썬의 함수는 엄청 강력합니다. 파이썬의 함수의 강력함을 배가시켜주는 두 요소, docstring과 decorator에 대한 소개입니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyukebox.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>파이썬으로 알아보는 일급 객체(first-class citizen)</title>
    <link href="http://gyukebox.github.io/2017/09/30/firstclass/"/>
    <id>http://gyukebox.github.io/2017/09/30/firstclass/</id>
    <published>2017-09-29T15:00:00.000Z</published>
    <updated>2017-12-26T21:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/python.png" alt=""></p><p>함수형 프로그래밍(functional programming) 을 공부하다보면, 가장 많이 나오는 말이 “일급 객체”, 혹은 “일급 시민” 일 겁니다. 일급 객체가 무엇인지 파이썬의 함수를 예시로 들어 알아보는 포스팅입니다.</p><a id="more"></a><p>일급 객체, 일급 함수라는 개념은 영국의 크리스토퍼 스트레이치라는 컴퓨터 과학자가 1960 년에 처음 소개한 개념이다. 일급 객체가 되려면 다음과 같은 조건을 만족해야 한다.</p><ul><li>변수나 데이터 구조 안에 담을 수 있다.</li><li>매개변수로 전달이 가능하다.</li><li>리턴값으로 사용될 수 있다.</li></ul><h2 id="파이썬의-함수는-일급-객체이다"><a href="#파이썬의-함수는-일급-객체이다" class="headerlink" title="파이썬의 함수는 일급 객체이다"></a>파이썬의 함수는 일급 객체이다</h2><p>해당 조건을 보면, <strong>파이썬의 함수는 일급 객체이다</strong> 라는 결론을 쉽게 도출할 수 있다. 왜냐하면 파이썬의 함수는 파라메터로 넘길 수 있고, 리턴값으로 사용될 수 있기 때문이다.</p><h3 id="변수나-데이터-구조-안에-담을-수-있다"><a href="#변수나-데이터-구조-안에-담을-수-있다" class="headerlink" title="변수나 데이터 구조 안에 담을 수 있다"></a>변수나 데이터 구조 안에 담을 수 있다</h3><p>파이썬의 함수는 변수에 할당할 수 있다. 다음 <code>greeting.py</code> 코드를 보면서 눈으로 확인해보자!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello friend!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'See you later!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greeting = hello</span><br><span class="line">greeting()</span><br><span class="line">print(greeting)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">greeting = bye</span><br><span class="line">greeting()</span><br><span class="line">print(greeting)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(type(greeting))</span><br></pre></td></tr></table></figure><p>greeting 은 function 타입의 변수이고, 처음에는 hello 였다가 나중에는 bye 로 바뀐 것을 볼 수 있을 것이다. 실행 결과와 greeting 의 타입을 확인해 보면 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python greeting.py</span><br><span class="line">Hello friend!</span><br><span class="line">&lt;function hello at 0x101863c80&gt;</span><br><span class="line"></span><br><span class="line">See you later!</span><br><span class="line">&lt;function bye at 0x101863d08&gt;</span><br><span class="line"></span><br><span class="line">&lt;class &apos;function&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="매개변수로-전달이-가능하다"><a href="#매개변수로-전달이-가능하다" class="headerlink" title="매개변수로 전달이 가능하다"></a>매개변수로 전달이 가능하다</h3><p>또한, 파이썬의 함수는 매개변수로 전달이 가능하다. 다음의 <code>addition.py</code> 코드를 보면서 눈으로 알아보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(func, arg1, arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'calculation:'</span>, func.__name__)</span><br><span class="line">    print(<span class="string">'result:'</span>, func(arg1, arg2))</span><br><span class="line"></span><br><span class="line">calculate(add_two, <span class="number">4</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><code>calculate</code> 함수에 <code>add_two</code> 함수를 넘긴 것을 볼 수 있다!<br>위의 코드를 실행하면 당연하게도, 다음과 같은 결과가 나온다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python addition.py</span><br><span class="line">calculation: add_two</span><br><span class="line">result: 14</span><br></pre></td></tr></table></figure><p>이런 표현법의 장점은, 기능을 수정하고 싶을 때에도 기존 코드를 전혀 수정하지 않고 기능 수정이 가능하는 점이다. 예를 들어, <code>calculate</code> 으로 두 수를 곱하는 연산을 행하고 싶다고 하면, <code>calculate</code> 함수를 전혀 수정하지 않은 채로, 두 수를 곱하는 함수 <code>multiply_two</code> 를 새로 정의한 후 <code>calculate</code> 함수에 인자로 넘겨주면 그만이다.</p><h3 id="리턴값으로-사용될-수-있다"><a href="#리턴값으로-사용될-수-있다" class="headerlink" title="리턴값으로 사용될 수 있다."></a>리턴값으로 사용될 수 있다.</h3><p>마지막으로, 파이썬의 함수는 리턴값으로 사용될 수 있다. 이것도 역시 눈으로 보면 이해가 쉽다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">document_it</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Running function:'</span>, func.__name__)</span><br><span class="line">        print(<span class="string">'Positional arguments:'</span>, args)</span><br><span class="line">        print(<span class="string">'Keyword arguments:'</span>, kwargs)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Result:'</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> new_function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_ints(3, 5) = 8</span></span><br><span class="line">decorated_add_ints = document_it(add_ints)</span><br><span class="line">print(decorated_add_ints(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>(어쩌다 보니 예제에서 일급객체의 세 가지 요소가 다 드러났다)<br><code>add_ints</code> 함수에 간단한 설명을 붙이려고 <code>document_it</code> 함수를 정의하였다. <code>document_it</code> 함수는 내부함수인 <code>new_function</code> 을 리턴하는 구조이다.<br>맨 밑의 두 줄도 유심히 살펴보자. <code>document_it</code> 함수에 <code>add_ints</code> 함수를 인자로 넘긴 후에, <code>decorated_add_ints</code> 에 저장하였다! 실행 결과를 살펴보면 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python decorator.py</span><br><span class="line">Running function: add_ints</span><br><span class="line">Positional arguments: (3, 5)</span><br><span class="line">Keyword arguments: &#123;&#125;</span><br><span class="line">Result: 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>(이 예제는 파이썬의 또 다른 문법인 데코레이터(<code>decorator</code>) 입니다. 데코레이터에 대해서는 추후 포스팅으로 찾아뵙겠습니다.)</p><h2 id="추가-함수가-일급-객체인-언어와-그렇지-않은-언어"><a href="#추가-함수가-일급-객체인-언어와-그렇지-않은-언어" class="headerlink" title="추가 - 함수가 일급 객체인 언어와 그렇지 않은 언어"></a>추가 - 함수가 일급 객체인 언어와 그렇지 않은 언어</h2><p>이제 “일급 객체” 란 무엇이고, 파이썬의 함수가 왜 일급 객체인지 알 수 있게 되었다. 그렇다면 다른 언어는 어떨까?</p><ul><li>함수가 일급 객체인 언어 : Javascript, Scala, Go</li><li>함수가 일급 객체가 아님 : C, Java</li></ul><p>(위의 언어가 전부가 아닙니다! 실제로 함수형 프로그래밍 언어는 많이 존재합니다)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/python.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;함수형 프로그래밍(functional programming) 을 공부하다보면, 가장 많이 나오는 말이 “일급 객체”, 혹은 “일급 시민” 일 겁니다. 일급 객체가 무엇인지 파이썬의 함수를 예시로 들어 알아보는 포스팅입니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyukebox.github.io/categories/Python/"/>
    
      <category term="Functional Programming" scheme="http://gyukebox.github.io/categories/Python/Functional-Programming/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
      <category term="함수형프로그래밍" scheme="http://gyukebox.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>PyCon Korea 2017 참석후기</title>
    <link href="http://gyukebox.github.io/2017/08/15/pycon/"/>
    <id>http://gyukebox.github.io/2017/08/15/pycon/</id>
    <published>2017-08-14T15:00:00.000Z</published>
    <updated>2017-12-26T21:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/pycon.png" alt=""></p><p>국내 최대규모 파이썬 컨퍼런스인 파이콘! 올해는 직접 가서 겪어봤습니다.</p><a id="more"></a><p>파이콘! 이름만 들어도 무슨 행사일지 알것같은 이 행사는 파이썬 컨퍼런스이다. 국내 파이써니스타들을 대상으로 한 대규모 컨퍼런스에 올해는 나도 참석했다(나도 나름 파이써니스타라고 생각했고, 또한 파이썬을 좋아하기 때문이다).<br>사실 작년까지만 해도 이런 행사가 존재하는지 조차도 몰랐는데, 올해 처음 간 파이콘에서 상상 이상의 충격을 받았다. 받은 충격을 여러분들과 공유하고자 함께 글을 쓴다.</p><h2 id="엄청-많은-사람"><a href="#엄청-많은-사람" class="headerlink" title="엄청 많은 사람"></a>엄청 많은 사람</h2><p>기술적인 부분에서도 충격을 많이 받았지만, 가장 충격을 받았던 건 바로 사람 수였다. <strong>사람이 무지막지하게 많았다!</strong> 이 많은 사람들이 다 파이썬 하는 사람들이라니 라고 생각하니깐 소름이 돋았다. “진짜 파이썬은 대세구나”, “파이썬이 얼마나 좋으면 이렇게 많은 사람들이 쓸까” 라는 생각이 저절로 머릿속에 맴돌았다. 행사에 등록하고 행사장에 딱 들어가는 순간 한 몇 분동안 “와” 밖에 안나왔다. (사실 아직까지도 파이썬이 좋은지 잘 모르겠다. 파이썬 뉴비라서 그런가…)</p><p>행사장에 들어서자마자 사람들이 엄청 길게 줄을 서 있었는데, 그 곳으로 가보니깐 바로 젯브레인에서 이벤트를 하고 있었다! 한치의 망설임도 없이 기다렸다. 왜냐면 나름대로 젯브레인 IDE 애호가였으니깐(<code>PyCharm</code>, <code>IntelliJ IDEA</code>, <code>CLion</code>, <code>Gogland</code> 이렇게 네 개 쓸 정도면 나름 애호가라고 해도 되지 않을까). 오랜 기다림 끝에 얻은 것은 바로 스티커와 젯브레인 요요였다. “좋아 젯브레인 스티커라면 이정도는 기다릴수 있지” 하고 행사의 시작을 알리는 키노트를 들으러 갔다.</p><h2 id="키노트"><a href="#키노트" class="headerlink" title="키노트"></a>키노트</h2><p>파이콘의 시작을 알리는 키노트는 두 개의 세션이 있었다. 첫 번째 세션은 현재까지 파이썬이 어떻게 변화하였고, 어떤 영향을 주었는지에 대한, 말 그대로 “파이썬 변천사” 였다. 하지만 별로 잘 공감하지 못하였다. 파이썬 3 으로 파이썬을 시작했는데 파이썬 1, 파이썬 2 에 대한 내용을 알 리가 만무했다. 그러나 파이썬이 엄청 발전했구나 라는 생각을 들었다. 지금 파이썬 3 에서 편리하게 쓰고 있는 기능들이 예전 버전에서는 안 됬다는 것을 들으니깐 말이다.<br>두 번째 세션은 파이콘을 준비한 분께서 엄청 재미있게 발표를 하셨는데, 기억에 남았던 것은 발표자분이 2014 년 파이콘에서 한 발표와 2016 년 파이콘에서 한 발표에서, 청중들의 웃음 빈도를 분석하여 “웃음 지수” 로 나타내어서, 발표가 얼마나 재미있었는가를 분석하는 프로젝트였다. 프로젝트 주제 뿐만 아니라, 파이썬의 활용도에서도 놀랐다.</p><p>이렇게 키노트가 끝났고, 밥을 먹고 와서 여러 가지 발표를 들으러 다녔다.</p><h2 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h2><p>컨퍼런스의 꽃인 세션! 파이콘 역시 국내 최대의 파이썬 컨퍼런스 답게 여러 가지 분야와 난이도의 세션이 마련되어 있었다. 발표자분 들 중에 내가 아는 분도 있었다! <del>하지만 안타깝게도 듣고싶었던 다른 세션과 시간이 완벽하게 겹쳐서 듣지 못했다.</del></p><p>세션은 한 분야에 치중해서 듣기보다는, 여러 분야에 걸쳐서 세션을 들었다. 분야라면 웹 개발, 데이터 분석, 딥러닝 정도가 있었다.</p><p><strong>웹 개발</strong> 세션에서는 주로 장고(<code>django</code>) 를 다뤘다. 장고를 경험해본 나로써는 세션들이 유익했다. 주로 장고 관련 꿀팁들(성능 개선 등) 과 숨겨진 기능들 을 다뤘다.</p><p><strong>데이터 분석</strong> 세션에서는 많은 공감이 되지 않았지만, (<del>데이터 분석에 관심이 별로 없었기 때문에</del>) “데이터로 보는 파이콘” 세션이 인상깊었다. 역대 파이콘 예산을 분석한 세션이었는데, 파이콘 준비하신 분들의 노고가 느껴지는 세션이었다.</p><p>하지만 뭐니뭐니해도 가장 인상깊었던 세션은 바로 <strong>딥러닝</strong> 세션이었다. 올해 파이콘 모토가 “Back to the Basic” 이었던 것 만큼이나, 발표자 분들이 엄청 쉽고 재미있게 발표를 잘 해 주셨다. 딥러닝이 무엇인가 부터 시작해서 프레임워크 소개까지, 무엇 하나 빠지는 게 없었다. 또한, 딥러닝의 결과물을 눈으로 보니 <strong>신기하고 재미있었다</strong>. 컴퓨터가 학습을 해서 결과물을 만들어낸다니, 놀라지 않을 수 없었다.<br>딥러닝 세션들을 듣고 엄청 감동받은 나머지, 행사장에서 <strong>바로 딥러닝 책을 사버렸다!</strong> (파이콘 스폰서 중에서 출판사가 여러 곳 있었는데, 해당 출판사에서 행사 당일 부스를 차리고 책 10% 할인 이벤트를 진행하길래, 바로 사버렸다) 과연 올해가 가기 전까지 산 책을 볼 수는 있을까, <del>학교 과제하고 팀플하다 보면 시간이 다 갈텐데 가 아니라 게을러서</del><br>올해 목표가 하나 더 늘었다. 바로 <strong>딥러닝 입문하기</strong>. 1 학년때 학교 과제로 여러가지 게임을 만들었는데, 그 게임을 플레이하는 AI 를 만들어보는 것으로 공부를 해볼까 한다.</p><p><strong>클라우드</strong> 관련 세션이 하나 있었다(사실 이 세션 들으러 지인 개발자분의 발표 세션을 포기했다). 하지만, 세션은 기대했던 것보다 많이 달랐다.</p><p>영어 세션도 있었지만 잘 들어오지 않았다. <del>전날 블로그 서버 고치느라 잠을 세시간 정도밖에 못 자고 가서 그랬던 것 같다</del> 영어능력이 퇴화한 것 같다. 다시 영어 공부를 시작해야하나…</p><h2 id="라이트닝-토크-프리토킹"><a href="#라이트닝-토크-프리토킹" class="headerlink" title="라이트닝 토크 + 프리토킹"></a>라이트닝 토크 + 프리토킹</h2><p>사실 이 항목이 파이콘의 재미를 두 배로 만들어줬다. 행사장 내에서는, 주제를 정하여 해당 주제에 관심 있는 사람들이 자유롭게 토론할 수 있는 공간이 있었는데, 나 또한 거기 가서 엄청 열심히 떠들었다. 역시 개발 관련 아무말 대잔치는 재밌다.</p><p>같이 프리토킹하러 오신 분들 중에 중학교 2 학년 분이 한 분 계셨다! 그분 말로는 스크래치(여러분들이 생각하시는 그 고양이 있는 스크래치가 맞습니다) 로 코딩을 시작하다가 재밌어서 계속 하게 되셨다고. 중학교 2 학년 분이 방에서 동일한 수준으로 토킹이 가능했다는 게 너무 놀랐다. 난 중 2 때 뭐했지…</p><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><p>여러 스타트업에서 부스를 차리고 홍보를 했다. 모든 부스를 다 돈 결과, <strong>스티커를 엄청 많이 받았다</strong>. 레진엔터테인먼트, 스마트스터디 같은 이름있는 스타트업 부터 처음 들어보는 스타트업 까지 엄청 많았다. 스타트업에 대한 로망이 한층 더 상승했다. 스타트업 가고 싶다!</p><p>기념품을 엄청 많이 받았다. 대충 나열해보자면,</p><ul><li>여러 종류의 개발스티커</li><li>파이콘 후드 + 에코백</li><li>IBM 티셔츠</li><li>엘라스틱서치(<code>elasticsearch</code>) 티셔츠</li><li>젯브레인 요요</li></ul><p>요 정도 되는것 같다.</p><p>여기까지가 저의 후기였습니다. 결론은, 파이썬 하는 사람들한테 엄청 좋은 컨퍼런스인 것 같습니다. 내년에는 아마 더 큰 규모로 파이콘이 열릴 거라고 하네요. 엄청 유익한 행사였습니다 다음에는 꼭 참여해보세요!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/pycon.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;국내 최대규모 파이썬 컨퍼런스인 파이콘! 올해는 직접 가서 겪어봤습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="컨퍼런스 후기" scheme="http://gyukebox.github.io/categories/%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4-%ED%9B%84%EA%B8%B0/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
      <category term="PyCon" scheme="http://gyukebox.github.io/tags/PyCon/"/>
    
      <category term="컨퍼런스" scheme="http://gyukebox.github.io/tags/%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4/"/>
    
      <category term="후기" scheme="http://gyukebox.github.io/tags/%ED%9B%84%EA%B8%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git 입문자를 위한 git 사용법</title>
    <link href="http://gyukebox.github.io/2017/08/10/git/"/>
    <id>http://gyukebox.github.io/2017/08/10/git/</id>
    <published>2017-08-09T15:00:00.000Z</published>
    <updated>2017-12-26T21:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/git.png" alt=""></p><p>개발할 때 코딩 실력이나만큼 중요한 것은 바로 버전 관리죠. 현재 거의 필수적으로 쓰이는 버전 관리 툴인 git 에 관하여 알아보는 포스트입니다. (git 을 아예 모르는 사람들을 대상으로 포스팅했습니다.)</p><a id="more"></a><p>해당 포스트에서는 터미널 명령어를 사용합니다. 터미널이 아직까지는 어려우신 분들은 <code>SourceTree</code> 를 활용하셔도 좋습니다(<code>SourceTree</code>에 관해서는 아래에 자세하게 명시하겠습니다).</p><h2 id="버전-관리-툴의-필요성"><a href="#버전-관리-툴의-필요성" class="headerlink" title="버전 관리 툴의 필요성"></a>버전 관리 툴의 필요성</h2><p>학교에서 팀 프로젝트를 해봤다면 이런 경험이 한 번쯤은 있었을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">철수 : (압축파일을 푼다) 영희야, 너가 보내준 파일 받았는데 여기 OOOO한 부분에서 문제가 있어.</span><br><span class="line">      그리고 그때 말한 그 부분 내가 만들었어. 파일 보냈어! (코드를 압축해서 카카오톡으로 보낸다)</span><br><span class="line">영희 : (압축파일을 푼다) 그런데 철수야, 그렇게 만들면 내가 만든 부분이랑 자료형이 달라서 안 맞아.</span><br><span class="line">      이러이렇게 만들어서 다시 보내줘. 내가 만든 부분을 지금 수정하기 힘들어.</span><br><span class="line">철수 : (한숨을 쉬며) 그래 알았어... (새로 만든 코드를 압축해서 카카오톡으로 보낸다)</span><br><span class="line">      여기 다 만들었다.</span><br><span class="line">영희 : 헉 잠시만 철수야, 앞에 만든 부분이 문제가 생겨서 수정해야 할 것 같거든?</span><br><span class="line">      (압축파일을 풀고 수정을 시도하지만, 역시 안 맞는 부분이 있다)</span><br><span class="line">      그런데 이제는 ㅁㅁㅁㅁ한 부분에서 안 맞아. 다시 수정해야 되겠는데?</span><br><span class="line">철수, 영희 : 하...</span><br></pre></td></tr></table></figure><p>보기만 해도 답답한 <del>암걸리는</del> 상황이다. 이럴 때, 서로의 코드에서 다른 부분을 알아서 잡아주는 도구가 있었으면 얼마나 편했을까?<br>또한, 카카오톡으로 매번 압축해서 파일을 보내고 압축을 풀고… 이런 불편한 작업 없이 소스코드를 한 곳에 모아서 관리할 수 있는 도구가 있었으면 얼마나 좋았을까?</p><p>이런 상황에서 사용하도록 만들어진 도구가 <code>git</code> 이다! <code>git</code>을 이용하면 위의 상황에서 훨씬 편리하게 작업중인 소스코드를 관리하는 것이 가능하다. 이제 <code>git</code>에 관하여 자세하게 알아보자!</p><h2 id="Git-설치하기"><a href="#Git-설치하기" class="headerlink" title="Git 설치하기"></a>Git 설치하기</h2><p>가장 먼저 할 일은, 역시나 설치이다. 설치 방법은 다음과 같다.</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>리눅스 배포판에 따라 다음 두 명령어 중 하나를 입력한다. (하나가 안되면 다른 거다)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p><code>Homebrew</code>가 설치되어 있다면, 다음 명령어만 입력하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><p>(Homebrew 는 맥용 패키지 관리 도구입니다. 설치 방법 및 자세한 내용은 <a href="https://brew.sh/index_ko.html" target="_blank" rel="noopener">https://brew.sh/index_ko.html</a> 를 참고하세요.)</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>안타깝게도, 윈도우에서는 커맨드라인 하나만으로 git 을 설치할 수 없기에, 공식 사이트(<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a>) 를 통해 설치하거나, <code>SourceTree</code>나 <code>Github Desktop</code> 같은 GUI 도구를 이용해야 한다. Command line tool 은 <a href="https://git-for-windows.github.io" target="_blank" rel="noopener">https://git-for-windows.github.io</a> 에서 다운로드 받을 수 있다.</p><p>(사실 초보자들한테는 GUI 툴이 더 시작하기는 좋습니다.)<br>(윈도우 10 부터는 cmd 에서 bash 명령어를 이용하는 것이 가능해졌습니다. 하지만, 많이 부족하여 아직 사용하기는 시기상조다 라는 의견이 많습니다.)</p><p>운영체제에 맞게 git 을 설치하였으면, 사용할 준비가 되었다!</p><h2 id="Git-시작하기"><a href="#Git-시작하기" class="headerlink" title="Git 시작하기"></a>Git 시작하기</h2><p>이제 git 을 본격적으로 사용해 보자!</p><h3 id="저장소-생성하기"><a href="#저장소-생성하기" class="headerlink" title="저장소 생성하기"></a>저장소 생성하기</h3><p>철수는 저번 프로젝트를 교훈삼아, 이번 프로젝트에서는 꼭 버전 관리 도구를 사용하기로 마음먹었고, git 을 사용하기로 하였다.<br>우선, 그는 자신이 작업중인 프로젝트 폴더로 들어가서, 다음 명령어로 git 을 시작했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /path/to/project</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p><code>git init</code> 명령어를 사용하면 현재 작업중인 프로젝트 폴더에 <code>.git</code> 이라는 숨김 파일이 만들어지고,<br>“git 저장소”가 생성된다. git 은 <code>.git</code> 파일이 위치하는 디렉토리 및 하위 디렉토리에 위치해 있는 파일들을 관리한다.<br>만약 각자 다른 프로젝트를, 따로 관리하고 싶다면, 각각의 프로젝트 폴더에서 각자 <code>git init</code> 을 사용해 주어야 한다.</p><h3 id="gitignore-파일"><a href="#gitignore-파일" class="headerlink" title=".gitignore 파일"></a>.gitignore 파일</h3><p>하지만, 모든 파일을 버전 관리에 포함하고 싶지는 않다. 가령 소스 파일을 빌드해서 만들어진 실행파일이나, 이미지 파일이나, 아니면 IDE 에서 자동으로 생성되지만 필요가 없는 폴더의 파일들(예: JetBrains IDE 의 <code>.idea</code>) 같은 경우는, 딱히 버전 관리를 해줄 필요가 없다.<br>Git 은 이렇게 사용자가 버전 관리를 하고 싶지 않은 파일들을 무시할 수 있는 기능이 있다. Git 이 무시하도록 하는 파일들을 명시하는 파일이 <code>.gitignore</code> 파일이다.</p><p>다시 철수로 돌아가보자. 철수는 자신이 작업하고 있는 프로젝트의 파일 중, 이미지 파일을 포함한 몇몇 파일은 버전 관리의 필요성을 느끼지 않아서, <code>.gitignore</code> 파일에 이를 추가했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br><span class="line">*.jpg</span><br><span class="line">*.png</span><br><span class="line">.idea/*</span><br><span class="line">.DS_Store</span><br></pre></td></tr></table></figure><p>(해당 예시는 그냥 예시일 뿐입니다. 꼭 이렇게 작성하라는 뜻이 아니라, 여러분들의 필요에 맞게 <code>.gitignore</code> 파일을 작성하시면 됩니다.)</p><p>예시를 자세히 보면 <code>.gitignore</code> 파일에서 무시 파일을 명시하는 방법은 아래와 같이 세 가지가 있음을 알 수 있는데,</p><ul><li>확장자를 명시하여 해당 확장자의 파일을 모두 무시</li><li>디렉토리를 명시하여 해당 디렉토리 아래의 파일을 모두 무시 (이 경우 subdirectory 도 포함)</li><li>파일 이름을 정확히 명시하여 해당 파일을 무시</li></ul><p>뭐 상황에 맞게 세 가지 방법 중 하나를 사용하면 된다.</p><h2 id="파일의-상태"><a href="#파일의-상태" class="headerlink" title="파일의 상태"></a>파일의 상태</h2><p>Git 에서는 현재 작업중인 프로젝트 파일의 상태를 다음과 같이 세 가지로 분류한다.</p><ul><li>작업 중인 상태</li><li>준비 상태</li><li>완료 상태</li></ul><p>그리고, git 저장소에는 (눈에는 보이지 않지만) 파일들의 상태를 구분하기 위하여 세 종류의 영역이 있는데,</p><ul><li><code>working directory</code> : 현재 작업 중인 실제 파일들</li><li><code>index</code> : 작업이 완료되어 확정을 준비하는 파일들 (이 영역에 파일들을 추가하는 행동을 <code>stage</code> 라고 한다)</li><li><code>HEAD</code> : 최종 확정본들 (이 영역에 파일을 추가하는 행동을 <code>commit</code> 이라고 한다)</li></ul><p><del>왜 HEAD 만 대문자일까</del><br>위와 같다. 그렇다면, git 에서 소스코드를 관리하는 과정은 다음과 같다는 것을 알 수 있게 된다.</p><ol><li>소스 코드 작업을 완료한다.</li><li>작업이 완료된 코드를 <code>index</code>에 <code>stage</code> 한다 (또는 스테이지에 올린다).</li><li>필요한 파일들을 모두 <code>stage</code> 했으면 묶어서 <code>HEAD</code>에 <code>commit</code>(커밋) 한다.</li></ol><p><del>어때요 참 쉽죠?</del><br>예를 들어, 철수는 웹사이트를 하나 제작하기 위해서 맨 처음 화면인 <code>index.html</code> 을 처음 만들었다고 하자. 그러면 철수는 이 “<code>index.html</code> 제작” 을 하나의 버전(단계) 로 생각하여, git 에서 <code>stage</code> 후 <code>commit</code> 으로 관리할 수 있게 된 것이다.</p><h2 id="상태-확인과-staging"><a href="#상태-확인과-staging" class="headerlink" title="상태 확인과 staging"></a>상태 확인과 staging</h2><p>철수는 소스 코드 작업을 마치고 현재 git 저장소의 상태를 알아보기 위하여 다음 명령어를 사용했다.<br><code>git status</code><br>이 명령어를 입력하니 다음과 같이 현재 파일들의 상태가 한 눈에 보였다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p><code>git status</code> 명령어를 사용하면, 현재 어떤 파일이 추가되고 삭제되었는지, 어떤 파일이 아직 추가되지 않았는지 볼 수 있다. 심지어 “추가하려면 <code>git add</code> 를 쓰세요” 라고 친절하게 알려준다! 그렇다, 파일을 <code>index</code>에 <code>stage</code> 하고 싶으면 <code>git add</code>를 사용하면 된다.</p><p>철수는 작업이 완료된 파일을 스테이지에 올리기 위하여 다음과 같이 진행했고, 상황을 한번 더 확인했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git add index.html</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   index.html</span><br></pre></td></tr></table></figure><p><code>git add &lt;파일이름&gt;</code> 을 사용해서 해당 파일을 스테이지에 올릴 수 있다.<br><code>git status</code> 를 사용하면, 스테이지에 올라간 파일들은 “change to be committed: “ 라는 문구 아래에 놓이고, 아직 스테이지에 올라가지 않은 파일들은 “untracked files: “ 라는 문구 아래에 놓이게 된다.</p><p>하지만, 일일이 모든 파일을 추가하자니 좀 귀찮은 감이 있다. 위와 같이 하나의 파일만을 추가하는 명령 말고도, 다음과 같은 표현들을 사용하면 한번에 여러 개의 파일들을 동시에 스테이지에 올릴 수가 있다.</p><ul><li><code>git add *.foo</code> : foo 확장자를 가진 모든 파일들을 스테이지에 올린다.</li><li><code>git add dir/*</code> : dir 디렉토리 안의 모든 파일들을 스테이지에 올린다.</li><li><code>git add --all</code> : 아직 스테이지에 올라가지 않은 모든 파일들을 스테이지에 올린다.</li></ul><p>하지만, 동일 확장자나 동일 디렉토리 안에 현재 버전에 포함시키고 싶지 않은 파일이 들어 있을 수도 있으므로 신중하게 써야 한다.</p><h2 id="Commit-과-commit-message"><a href="#Commit-과-commit-message" class="headerlink" title="Commit 과 commit message"></a>Commit 과 commit message</h2><p>철수는 필요한 모든 파일들을 스테이지에 올렸다. 스테이지에 올라간 파일들을 묶어서 커밋하기 위하여 다음과 같이 명령어를 사용하였다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;Initial commit : added index.html&quot;</span><br><span class="line">[master (root-commit) 772f2e6] Initial commit : added index.html</span><br><span class="line"> 1 file changed, 8 insertions(+)</span><br><span class="line"> create mode 100644 index.html</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>git 에 내용을 커밋할 때는 위와 같이 <code>git commit -m &quot;commit message&quot;</code> 라는 명령어를 사용한다. 그러면 친절하게 커밋의 내용을 보여준다. 또한 커밋 이후에 <code>git status</code> 로 상태를 확인하면 다음과 같이 보이게 된다. (물론 아직 커밋을 안 한 파일이 있으면 다르게 나온다.)</p><p>앞의 과정들과 약간 다른 점은, 커밋을 할 때에는 커밋 메시지(commit message) 를 작성한다는 점인데, 현재 개발자가 무슨 작업을 진행했는지 알 수 있도록 하기 위해서다. 따라서, 커밋 메시지는 <strong>간결하지만 자세하게</strong> 작성해야 한다! (<del>이것은 마치 따뜻한 냉커피..</del>)<br>길지 않으면서, 현재 작업을 통하여 예전과 변경된 점이 명확하게 드러나도록 작성하면 좋은 커밋 메시지가 될 수 있다.</p><h2 id="원격-저장소"><a href="#원격-저장소" class="headerlink" title="원격 저장소"></a>원격 저장소</h2><p>철수는 이제 작업한 내용을 영희한테 보여줄 준비가 되었다. 하지만 또 파일을 압축해서 카카오톡으로 보낸다는 건 상상도 하기 싫은 일. 따라서, 현재 저장소와 연동할 수 있는 <strong>원격 저장소</strong> 를 두기로 하였다. 그래서, 다음과 같이 했다.</p><p>우선 <code>GitHub</code> 에서 레포지토리를 하나 만들었다. 그 다음, 아래의 명령어로 깃허브 원격 저장소랑 현재 저장소를 연동시켰다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/gyukebox/gittutorial.git</span><br></pre></td></tr></table></figure><p>(GitHub 저장소는 그냥 만들면 됩니다. 깃허브 가서 Create Repository 누르면 친절하게 나옵니다.)<br><code>git remote add [단축이름] [url]</code> 명령어를 사용하여 url 의 원격 저장소를 단축 이름을 사용하여 현재 git 저장소랑 연동시켰다(github 말고도 다른 원격 저장소들도 있지만, 거의 다 github 를 사용하므로 예시도 그냥 github 로 들겠습니다).</p><p>현재 저장소에 연동된 원격 저장소들을 보려면 다음과 같은 명령어를 사용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/gyukebox/gittutorial.git (fetch)</span><br><span class="line">originhttps://github.com/gyukebox/gittutorial.git (push)</span><br></pre></td></tr></table></figure><p>여기서 <code>-v</code> 옵션은 verbose 의 의미로, “자세히” 라는 뜻이다. 저 옵션을 붙이지 않으면 그냥 단축 이름만 나오지만, 옵션을 붙이면 원격 저장소 url 과 같이 나온다.</p><h3 id="원격-저장소에-올리기-push"><a href="#원격-저장소에-올리기-push" class="headerlink" title="원격 저장소에 올리기(push)"></a>원격 저장소에 올리기(push)</h3><p>이제 원격 저장소도 만들었으니, 원격 저장소에 현재 작업한 내용들을 올리는 일만 남았다. 철수는 다음과 같이 현재 작업 내용을 올렸다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 314 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/gyukebox/gittutorial.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><p><code>git push [원격 단축이름] [브랜치]</code> 명령어를 사용하면, 해당 단축이름을 가지는 원격 저장소로 코드가 올라가게 된다. 여기서 <code>master</code>는 <strong>브랜치</strong> 인데, 2 명 이상이 협업할 때 아주 중요한 개념이 된다(<code>master</code>는 기본 브랜치 이름입니다. 브랜치에 관해서는 아직 자세히 모르셔도 됩니다. 추후 포스팅으로 찾아뵙겠습니다).</p><p>이제 철수는 원격 저장소를 통하여 소스 코드를 올리므로 더 이상 영희에게 파일을 압축하여 카카오톡으로 보내지 않아도 된다! 영희가 해당 저장소 링크로 들어가서 코드를 확인하면 그만이니깐.</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><code>git</code> 에 관한 아주 기본적인 개념들을 알아봤는데, 간단하게 정리하면 다음과 같이 요약할 수 있다.</p><ul><li><code>git init</code> : 새로운 git 저장소를 만든다.</li><li><code>git status</code> : 현재 저장소의 상황을 본다.</li><li><code>git add &lt;file&gt;</code> : 파일을 스테이지에 올린다.</li><li><code>git commit -m &quot;commit message&quot;</code> : 메시지와 함께 커밋한다.</li><li><code>git remote add [name] [url]</code> : 원격 저장소를 추가한다.</li><li><code>git push [remote] [branch]</code> : 원격 저장소에 올린다.</li></ul><h2 id="앞으로-더-알아볼-내용"><a href="#앞으로-더-알아볼-내용" class="headerlink" title="앞으로 더 알아볼 내용"></a>앞으로 더 알아볼 내용</h2><p>(추후 포스팅으로 해당 개념들에 대하여 설명하겠습니다.)</p><ul><li>원격 저장소에서 가져오기 : <code>pull</code> 과 <code>clone</code></li><li>원격 저장소의 설명을 담당하는 <code>README.md</code></li><li>브랜치(branch)</li><li><code>pull request</code> 와 <code>merge</code></li><li><code>rebase</code></li></ul><h2 id="참고한-글들"><a href="#참고한-글들" class="headerlink" title="참고한 글들"></a>참고한 글들</h2><ul><li><a href="https://rogerdudler.github.io/git-guide/index.ko.html" target="_blank" rel="noopener">https://rogerdudler.github.io/git-guide/index.ko.html</a></li><li><a href="http://blog.weirdx.io/post/45529" target="_blank" rel="noopener">http://blog.weirdx.io/post/45529</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/git.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;개발할 때 코딩 실력이나만큼 중요한 것은 바로 버전 관리죠. 현재 거의 필수적으로 쓰이는 버전 관리 툴인 git 에 관하여 알아보는 포스트입니다. (git 을 아예 모르는 사람들을 대상으로 포스팅했습니다.)&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://gyukebox.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://gyukebox.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to GyuLog!</title>
    <link href="http://gyukebox.github.io/2017/08/08/welcome/"/>
    <id>http://gyukebox.github.io/2017/08/08/welcome/</id>
    <published>2017-08-07T15:00:00.000Z</published>
    <updated>2017-12-26T21:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>저의 블로그에 오신 것을 환영합니다! 앞으로 이곳을 개발 이야기들로 채워보겠습니다.</p><a id="more"></a><p>포스팅들의 주제는,</p><ul><li><code>Python</code>, <code>JavaScript</code>, <code>Cloud Computing</code> 관련 기술 이야기</li><li>Data Science, Machine Learning 관련 기술 이야기</li><li>컨퍼런스 및 여러 개발 행사 참여 후기</li><li><del>저의 삽질 후기</del></li></ul><p>가 될 것 같습니다. 다시 한번 환영합니다!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;저의 블로그에 오신 것을 환영합니다! 앞으로 이곳을 개발 이야기들로 채워보겠습니다.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
