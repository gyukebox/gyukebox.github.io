<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GyuLog</title>
  
  <subtitle>Byeong Gyu&#39;s dev blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gyukebox.github.io/"/>
  <updated>2017-12-26T21:22:16.000Z</updated>
  <id>http://gyukebox.github.io/</id>
  
  <author>
    <name>Byeong Gyu Choi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django 2.0 의 주 변경사항 살펴보기!</title>
    <link href="http://gyukebox.github.io/2017/12/27/django-2.0-url/"/>
    <id>http://gyukebox.github.io/2017/12/27/django-2.0-url/</id>
    <published>2017-12-26T15:00:00.000Z</published>
    <updated>2017-12-26T21:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><br>    <img src="/images/django.png"><br></div><p>Django 2.0 이 릴리즈 되었습니다! 1.11 버전과 비교해 다른 주요 상황들을 살펴봄과 동시에, 2.0에서만 지원하는 핵심 기능들을 소개합니다!</p><a id="more"></a> <p><code>Django</code> 2.0 이 12 월 2 일 자로 정식 출시 되었습니다! <del>그런데 왜 포스팅은 12 월 27 일?</del><br>써본 결과, 확실히 1.11 버전 보다 편해진 점이 많은 것 같은데, 이전 버전과 비교함과 동시에 2.0 버전의 핵심 기능을 소개하고자 해당 포스팅을 준비하게 되었습니다.</p><h2 id="호환되는-Python-버전"><a href="#호환되는-Python-버전" class="headerlink" title="호환되는 Python 버전"></a>호환되는 Python 버전</h2><p>Django 2.0 은 파이썬 3.4, 3.5, 3.6 과 호환됩니다(현재 가장 최신 파이썬 버전은 3.6.4 입니다).<br>네 그렇습니다. <strong>파이썬 2 의 지원을 django 2.0 에서는 공식적으로 중단</strong>하게 된 것입니다! (아마 1.11 에서 2.0 으로 버전이 뛴 큰 원인 중 하나인 것 같습니다)</p><p>또한, 파이썬 3.4 를 지원하는 마지막 버전이라고 합니다. 또한, 2019 년 3 월까지만 파이썬 3.4 를 지원 할 예정이라고 하므로, 파이썬 3.4 버전을 배포하려고 하시는 분들은 1.11 버전에 머물러 게시는 게 좋다고 합니다(2020 년 4 월까지 지원 예정).</p><p>구 파이썬 버전에 대한 내용을 <a href="https://docs.djangoproject.com/en/2.0/releases/2.0/#python-compatibility" target="_blank" rel="noopener">Django 공식 문서</a>에서 발췌하였습니다.</p><blockquote><p>The Django 1.11.x series is the last to support Python 2.7.</p><p>Django 2.0 will be the last release series to support Python 3.4. If you plan a deployment of Python 3.4 beyond the end-of-life for Django 2.0 (April 2019), stick with Django 1.11 LTS (supported until April 2020) instead. Note, however, that the end-of-life for Python 3.4 is March 2019.</p></blockquote><p>(얼른 파이썬 3 으로 넘어오세요!)<br>이제부터는 장고 2.0 의 주요 변경사항을 살펴보도록 하겠습니다!</p><h2 id="URL-패턴의-단순화"><a href="#URL-패턴의-단순화" class="headerlink" title="URL 패턴의 단순화"></a>URL 패턴의 단순화</h2><p>(아마 거의 모든 분들이 같은 생각이시겠지만) 장고 2.0 을 쓰면서 가장 편해졌다고 느낀 변경사항이 아닐 까 합니다!</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$'</span>, views.year_archive),</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>위 예시처럼 정규표현식을 사용해야 했던 url 을,</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/'</span>, views.year_archive),</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>다음과 같이 간단하게, 훨씬 쉽게 사용할 수 있습니다!<br>변경 사항을 살펴보면,</p><ul><li>기존 <code>django.conf.urls</code> 모듈에 있던 url 관련 함수들은, <code>django.urls</code> 로 옮겨졌습니다.</li><li><code>django.conf.urls.url()</code> 대신, <code>django.urls.path()</code> 함수를 사용할 수 있습니다!</li><li><code>include()</code> 함수 또한 <code>django.urls</code> 로 옮겨졌습니다.</li></ul><p>이 정도입니다.<br>기존 정규식을 사용한 url 표현을 하지 못하는 것은 아닙니다. <code>django.urls.re_path()</code> 함수를 사용하시면 여전히,</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re_path(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$'</span>, views.year_archive),</span><br></pre></td></tr></table></figure><p>다음과 같이 정규식을 사용하실 수 있습니다.</p><p>개인적인 의견) 기존에 정규식을 많이 사용해보신 분들이라면 <code>re_path</code> 가 편하실 수 있다고 생각합니다. 하지만, 가독성 부분에서는 새로운 방식인 <code>path</code> 를 사용하는 것이 더 낫다고 생각합니다.</p><h2 id="더욱-친화적으로-변한-모바일-admin-사이트"><a href="#더욱-친화적으로-변한-모바일-admin-사이트" class="headerlink" title="더욱 친화적으로 변한 모바일 admin 사이트"></a>더욱 친화적으로 변한 모바일 <code>admin</code> 사이트</h2><p>모바일 관리자 페이지가 반응형으로 바뀌었습니다!</p><table><thead><tr><th style="text-align:center">아이폰 화면</th><th style="text-align:center">안드로이드 화면</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/images/django-admin-mobile-iphone.png" alt=""></td><td style="text-align:center"><img src="/images/django-admin-mobile-android.png" alt=""></td></tr></tbody></table><h2 id="새로-생긴-사항-요약"><a href="#새로-생긴-사항-요약" class="headerlink" title="새로 생긴 사항 요약"></a>새로 생긴 사항 요약</h2><p>지금까지는 장고 2.0 에서 새로 생긴 사항들을 살펴보았습니다. 간단하게 요약하자면,</p><ul><li>파이썬 2.7 버전의 지원이 공식적으로 중단되었다.</li><li>정규표현식을 사용하지 않는, 간단한 url 매핑이 가능해졌다.</li><li><code>admin</code> 페이지가 반응형으로, 이쁘게 변하였다.</li></ul><p>이 정도 되겠습니다.</p><h2 id="삭제된-사항들"><a href="#삭제된-사항들" class="headerlink" title="삭제된 사항들"></a>삭제된 사항들</h2><p>지금부터는 2.0 으로 오면서 삭제된 사항들을 살펴보도록 하겠습니다.</p><h3 id="bytestring-에-대한-지원-일부-삭제"><a href="#bytestring-에-대한-지원-일부-삭제" class="headerlink" title="bytestring 에 대한 지원 일부 삭제"></a><code>bytestring</code> 에 대한 지원 일부 삭제</h3><p>파이썬 2 에 대한 지원 중단과 동시에, <code>bytestring</code> 에 대한 지원도 일부 삭제되었습니다. (예시: <code>reverse()</code> 함수는 <code>force_text()</code> 대신에 <code>str()</code> 함수를 사용합니다)</p><p>파이썬 3 에서의 모든 문자열은 <strong>유니코드</strong> 입니다! (파이썬 2 에서는 바이트) 바이트를 계속 사용하고 싶으시다면, <code>bytes</code> 타입을 사용하셔야 할 것입니다.<br>이제 <code>b&#39;some text&#39;</code>는 , <code>&quot;b&#39;some_text&quot;</code> 처럼 읽혀질 것입니다.</p><h3 id="오라클-11-2-에-대한-지원-중단"><a href="#오라클-11-2-에-대한-지원-중단" class="headerlink" title="오라클 11.2 에 대한 지원 중단"></a>오라클 11.2 에 대한 지원 중단</h3><p>오라클 데이터베이스 11.2 버전에 대한 지원이 중단되었습니다. (가장 최신 버전은 12.x)</p><h2 id="Last-but-not-least…"><a href="#Last-but-not-least…" class="headerlink" title="Last, but not least…"></a>Last, but not least…</h2><p>처음 장고 어플리케이션을 만들고 서버를 실행하면,<br><img src="/images/django-at-start.png" alt=""></p><p>기존에, It works! 문구가 사라지고, 다음과 같이 예쁜 시작 화면이 나오네요!</p><h2 id="기타-변경사항"><a href="#기타-변경사항" class="headerlink" title="기타 변경사항"></a>기타 변경사항</h2><p>기타 변경사항은 <a href="https://docs.djangoproject.com/en/2.0/releases/2.0/" target="_blank" rel="noopener">장고 2.0 공식 릴리즈 문서</a> 에서 확인하실 수 있습니다.</p><p>이번 포스트에서는 간단하게, 장고 2.0 이 출시되면서 기존의 장고와 비교하여 달라진 점을 살펴보았습니다. 개인적인 한줄 요약은, “초보자가 사용하기 편해진 것 같다” 입니다. (URL 매핑 변화가 이걸?)</p><p>+) 시일 내에, 장고 입문 시리즈를 연재할 계획입니다. 많이 봐주시면 감사하겠습니다! :D</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;br&gt;    &lt;img src=&quot;/images/django.png&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;Django 2.0 이 릴리즈 되었습니다! 1.11 버전과 비교해 다른 주요 상황들을 살펴봄과 동시에, 2.0에서만 지원하는 핵심 기능들을 소개합니다!&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyukebox.github.io/categories/Python/"/>
    
      <category term="Django" scheme="http://gyukebox.github.io/categories/Python/Django/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
      <category term="Web" scheme="http://gyukebox.github.io/tags/Web/"/>
    
      <category term="Django" scheme="http://gyukebox.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Python 함수의 docstring 과 decorator</title>
    <link href="http://gyukebox.github.io/2017/10/03/docstring_decorator/"/>
    <id>http://gyukebox.github.io/2017/10/03/docstring_decorator/</id>
    <published>2017-10-02T15:00:00.000Z</published>
    <updated>2017-12-26T21:22:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/python.png" alt=""></p><p>파이썬의 함수는 엄청 강력합니다. 파이썬의 함수의 강력함을 배가시켜주는 두 요소, docstring과 decorator에 대한 소개입니다.</p><a id="more"></a><p>이번 포스팅은, 파이썬의 함수 중 함수를 서식하는 기능을 하는 <code>docstring</code>과 <code>decorator</code>에 관한 내용이다. 특히 데코레이터 같은 경우에는 처음 접하는 경우에는 “저게 뭐지?” 하고 느낄 수 있지만, 잘 사용하면 매우 강력한 도구가 되는 만큼 잘 알고 가는 것이 좋다.<br>(이번 포스팅에서는 함수에 적용되는 데코레이터만 다룹니다. 클래스를 데코레이터로 만들 수도 있어요, 하지만 여기서는 다루지 않고 오로지 함수에만! 집중해 보겠습니다.)</p><h2 id="Docstring"><a href="#Docstring" class="headerlink" title="Docstring"></a>Docstring</h2><p>함수가 어떤 일을 하는지에 대한 설명은 보통 코드 내에서는 주석으로 쓰고, 외부에서는 wiki 페이지를 이용한다던가 해서 문서화시켜서 정리하곤 한다. 하지만, 파이썬에서는, 함수에 대한 설명을 함수 내에 넣을 수 있는 기능이 있는데, 그게 바로 <code>docstring</code> 이다.</p><p>일단 코드를 살펴보자</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">piglatin</span><span class="params">(word)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param word: word that would be changed into piglatin</span></span><br><span class="line"><span class="string">    :return: piglatin version of word</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> word[<span class="number">1</span>:] + word[<span class="number">0</span>] + <span class="string">'ay'</span></span><br></pre></td></tr></table></figure><p>눈치챘겠지만, docstring 은 document string 을 줄인 말이다. 위의 코드와 같이 함수 시작 부분에 큰따옴표 3 개를 연달아 붙임으로써 docstring 을 정의할 수 있다.</p><p>함수의 docstring 을 출력하고 싶으면 다음과 같이 하면 된다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>piglatin(<span class="string">'word'</span>)</span><br><span class="line"><span class="string">'ordway'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(piglatin)</span><br><span class="line">Help on function piglatin <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">piglatin(word)</span><br><span class="line">    :param word: word that would be changed into piglatin</span><br><span class="line">    :<span class="keyword">return</span>: piglatin version of word</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(piglatin.__doc__)</span><br><span class="line"></span><br><span class="line">    :param word: word that would be changed into piglatin</span><br><span class="line">    :<span class="keyword">return</span>: piglatin version of word</span><br></pre></td></tr></table></figure><p><code>help</code> 함수를 활용하면 함수의 docstring 을 출력할 수 있다. 위와 같이 서식이 갖추어져서 나온다.<br>또한, 서식 없이 docstring 을 있는 그대로 보고 싶으면, 함수의 <code>__doc__</code> 필드를 출력하면 된다.</p><h3 id="함수에-필드가-있다"><a href="#함수에-필드가-있다" class="headerlink" title="함수에 필드가 있다?"></a>함수에 필드가 있다?</h3><p>사실 docstring 은 간단한 주석이 아니라, 함수의 여러가지 필드(변수) 중 <code>__doc__</code> 변수에 들어간다 (<code>__doc__</code> 필드는 docstring 을 위하여 만들어졌다). 함수에도 여러가지 변수가 있는데(위의 <code>__doc__</code> 과 함수 이름이 저장되는 <code>__name__</code> 이 대표적이다), 왜냐하면 함수도 하나의 클래스이기 때문이다!</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(piglatin)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><p>데코레이터, 이름을 딱 보고 무언가를 꾸며주는 것이구나 라고 생각했다면 그게 바로 정답이다! 데코레이터는 기존의 코드에 여러가지 추가 기능을 적용시키는 파이썬의 한 문법인데, <strong>주로 함수의 형태로 많이 쓰인다</strong>.</p><p>데코레이터를 보다 잘 알기 위해서는 <a href="http://www.gyuveloper.com/post?6" target="_blank" rel="noopener">일급 객체</a>가 무엇인지, 그리고 파이썬의 함수가 왜 일급 객체인지를 이해하고 있어야 한다. 만약 일급 객체라는 단어가 생소하거나, 파이썬 함수가 왜 일급 객체인지 아리송하다면 해당 내용을 먼저 보고 오는 것을 추천드린다.</p><p>가장 좋은 방법은 역시 눈으로 보고 이해하는 것. 다음 코드를 함께 살펴보자.<br>(파일 이름을 <code>decorator.py</code> 라고 하겠다)</p><h3 id="데코레이터-함수의-일반적인-형식-그리고-특징"><a href="#데코레이터-함수의-일반적인-형식-그리고-특징" class="headerlink" title="데코레이터 함수의 일반적인 형식, 그리고 특징"></a>데코레이터 함수의 일반적인 형식, 그리고 특징</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">document_it</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Running function:'</span>, func.__name__)</span><br><span class="line">        print(<span class="string">'Positional arguments:'</span>, args)</span><br><span class="line">        print(<span class="string">'Keyword arguments:'</span>, kwargs)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Result:'</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> new_function</span><br></pre></td></tr></table></figure><p>(<code>document_it</code> 함수를 잘 살펴보면, <strong>매개변수도 함수이고, 반환값도 함수</strong>인 것을 눈치챌 수 있는데, <strong>파이썬의 함수는 일급 객체임을 단편적으로 보여주는 예시가 된다</strong>.)</p><p><code>document_it</code> 과 같은 형태를 가지는 함수를 <strong>데코레이터 함수</strong>라고 부르는데, 데코레이터 함수의 특징을 살펴보면,</p><ul><li>함수를 매개변수로 받는다(위의 예제에서는 <code>func</code>). 해당 함수는 데코레이터가 적용되는 대상이 된다.</li><li>데코레이터 함수 내에서 내부 함수가 정의되고, 정의한 내부 함수를 리턴한다. 데코레이터 함수에 인자로 넘어온 함수를, <strong>내부 함수가 꾸며주게 된다</strong>.</li></ul><p>한 문장으로 위의 예시를 들어서 요약하면, <strong><code>func</code>을 <code>new_function</code>이 꾸며준다!</strong></p><p>위의 <code>document_it</code>의 경우에는 어떻게 될까? <code>new_function</code> 을 살펴보면 함수에 대한 정보들을 출력해주고, 함수를 실행한 후 결과를 리턴하는데, 아마도 <code>func</code> 에 대한 정보를 출력해준 다음 <code>func</code> 을 실행한 결과를 리턴하게 되겠구나 라는 것을 예상할 수 있다.</p><h3 id="수동으로-데코레이터-붙이기"><a href="#수동으로-데코레이터-붙이기" class="headerlink" title="수동으로 데코레이터 붙이기"></a>수동으로 데코레이터 붙이기</h3><p>데코레이터를 적용시켜보면,</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_ints(3, 5) = 8</span></span><br><span class="line">decorated_add_ints = document_it(add_ints)</span><br><span class="line">print(decorated_add_ints(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>위와 같이 두 정수를 더하는 <code>add_ints</code> 에 <code>document_it</code> 데코레이터 함수를 붙여서, <code>decorated_add_ints</code> 변수에 저장하였다(함수를 변수에 저장할 수 있는건 파이썬에서 함수는 일급 객체니까!). <code>decoreated_add_ints</code> 에 3 과 5 를 넣어서 실행해보면, <code>add_ints</code> 에 대한 정보가 쭉 나오고, 결괏값인 8 이 출력될 것임을 예상할 수 있는데,<br>아니나 다를까, 실행 결과는,</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">python</span> decorator.<span class="keyword">py</span></span><br><span class="line">Running <span class="function"><span class="keyword">function</span>: <span class="title">add_ints</span></span></span><br><span class="line">Positional <span class="keyword">argument</span><span class="variable">s:</span> (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">Keyword <span class="keyword">argument</span><span class="variable">s:</span> &#123;&#125;</span><br><span class="line">Resul<span class="variable">t:</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>만약 그냥 <code>add_ints</code> 만 호출했다면 그냥 8 이 리턴되었겠지만, <code>document_it</code> 데코레이터 함수를 붙여서 실행하면 위와 같이 <strong>추가로 기능이 붙어서 실행된다</strong>.</p><p>아마 눈치 빠른 사람들은 알아챘겠지만, <strong>추가 기능을 붙이기 위해서 원래 함수를 수정하지 않아도 된다는 점</strong> 이 데코레이터의 제일 큰 장점 중 하나이다! 현실적인 예시를 들어보자. 함수를 디버깅하기 위해서 함수 내에 전달된 인자의 변화를 관찰하고 싶을 때, <code>print</code> 문을 추가하면 쉽게 볼 수 있지만, 원래 함수를 수정해야 하는 불편함이 있다. 이 때, <code>print</code> 문으로 함수의 인자를 출력하게 해주는 데코레이터 함수를 작성하여 붙인다면, 원함수의 수정 없이 더욱 편리하게 디버깅을 할 수 있다.</p><h3 id="보다-편리한-데코레이터-사용법"><a href="#보다-편리한-데코레이터-사용법" class="headerlink" title="보다 편리한 데코레이터 사용법"></a>보다 편리한 데코레이터 사용법</h3><p>위의 예제에서는 수동으로 데코레이터를 붙이는 방법을 살펴보았는데, 이번에는 보다 편리하게 데코레이터를 함수에 사용해보자. <code>decorator.py</code>의 <code>add_ints</code> 와 그 밑의 부분을 다음과 같이 수정해보자.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@document_it</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">print(add_ints(<span class="number">5</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>수동으로 데코레이터 함수를 붙이는 부분이 없어진 대신에, <code>add_ints</code> 위에 한 줄이 추가되었다.<br>그렇다, <code>@decorator_function</code> 을 사용하면, 함수에 데코레이터 함수를 붙일 수 있다. 위의 예제에서는 <code>add_ints</code> 함수에 <code>document_it</code> 데코레이터 함수가 자동으로 붙게 된다. 따라서, <code>add_ints</code> 함수를 그냥 실행해도,</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">python</span> decorator.<span class="keyword">py</span></span><br><span class="line">Running <span class="function"><span class="keyword">function</span>: <span class="title">add_ints</span></span></span><br><span class="line">Positional <span class="keyword">argument</span><span class="variable">s:</span> (<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">Keyword <span class="keyword">argument</span><span class="variable">s:</span> &#123;&#125;</span><br><span class="line">Resul<span class="variable">t:</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>위와 같이 데코레이터가 적용된 모습을 확인할 수 있다!</p><h3 id="두-개-이상의-데코레이터"><a href="#두-개-이상의-데코레이터" class="headerlink" title="두 개 이상의 데코레이터"></a>두 개 이상의 데코레이터</h3><p>만약 <code>decorator_py</code>에서 <code>add_ints</code>의 결과를 제곱하는 기능을 추가하고 싶다고 하면 어떻게 될까? 물론 <code>add_ints</code>를 수정할 수도 있겠지만, 데코레이터를 이용하여 수정 없이 기능을 추가하여 보자.</p><p><code>decorator_py</code> 에 다음과 같은 수정을 가해보자.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_it</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> result * result</span><br><span class="line">    <span class="keyword">return</span> new_function</span><br><span class="line"></span><br><span class="line"><span class="meta">@document_it</span></span><br><span class="line"><span class="meta">@square_it</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br></pre></td></tr></table></figure><p>한 번 봤으니 두 번은 어렵지 않다. <code>square_result</code> 는 데코레이터 함수이고, <code>add_ints</code> 에 두 개의 데코레이터를 붙인 경우이다.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">python</span> decorator.<span class="keyword">py</span></span><br><span class="line">Running <span class="function"><span class="keyword">function</span>: <span class="title">add_ints</span></span></span><br><span class="line">Positional <span class="keyword">argument</span><span class="variable">s:</span> (<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">Keyword <span class="keyword">argument</span><span class="variable">s:</span> &#123;&#125;</span><br><span class="line">Resul<span class="variable">t:</span> <span class="number">81</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><p>어, 실행 결과는 예상했던 것과는 살짝 다르다. <code>add_ints</code> 의 실행 결과는 9 지만, 이를 제곱하여 출력하고 싶어서 <code>square_it</code> 데코레이터를 붙였는데, <code>add_ints</code> 의 결과 자체가 81 이 되어버렸다! 이유는 바로 <strong>데코레이터의 실행 순서</strong> 에 있다. 함수에 2 개 이상의 데코레이터가 붙은 경우, <strong>함수 바로 위에 붙은 데코레이터부터(def 바로 위) 역순으로 실행된다</strong>. 위의 경우에는, <code>square_it</code> 데코레이터가 먼저 실행된 후, <code>document_it</code> 데코레이터가 실행되었으므로, <code>add_ints</code> 의 결과 자체가 81 로 바뀌어버린 것이다.</p><p>그렇다면, 두 데코레이터의 실행순서를 바꿔주면…</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@square_it</span></span><br><span class="line"><span class="meta">@document_it</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a, b</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">python</span> decorator.<span class="keyword">py</span></span><br><span class="line">Running <span class="function"><span class="keyword">function</span>: <span class="title">add_ints</span></span></span><br><span class="line">Positional <span class="keyword">argument</span><span class="variable">s:</span> (<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">Keyword <span class="keyword">argument</span><span class="variable">s:</span> &#123;&#125;</span><br><span class="line">Resul<span class="variable">t:</span> <span class="number">9</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure><p>우리가 원했던 그림이 나왔다!</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p>이번 포스팅의 내용을 간추려보면,</p><ul><li><code>docstring</code> 은 함수 내부에 설명을 추가한 문자열이고, 함수의 <code>__doc__</code> 변수에 저장된다.</li><li>Docstring 에 관한 컨벤션 - <a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP 257</a></li><li><code>decorator</code> 은 함수에 붙어서, 붙여진 함수를 꾸며주는 역할을 한다.</li><li>데코레이터 함수의 기본 형식은,</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_function</span><span class="params">(original_function)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_function</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="comment"># YOUR_CODE_HERE</span></span><br><span class="line">    <span class="keyword">return</span> wrapper_function</span><br></pre></td></tr></table></figure><p>이다. <code>original_function</code>에 <code>wrapper_function</code> 의 기능을 덧붙여준다.</p><ul><li>함수에 두 개 이상의 데코레이터가 붙은 경우, 함수에서 가까운 데코레이터부터 차례대로 실행된다.</li><li>Decorator 에 관한 컨벤션 - <a href="https://www.python.org/dev/peps/pep-0318/" target="_blank" rel="noopener">PEP 318</a></li></ul><p>이제 <code>docstring</code>을 이용하여 함수에 쉽게 주석을 달고, <code>decorator</code>을 이용하여 함수에 추가 기능들을 덧붙여보자!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/python.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;파이썬의 함수는 엄청 강력합니다. 파이썬의 함수의 강력함을 배가시켜주는 두 요소, docstring과 decorator에 대한 소개입니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyukebox.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>파이썬으로 알아보는 일급 객체(first-class citizen)</title>
    <link href="http://gyukebox.github.io/2017/09/30/firstclass/"/>
    <id>http://gyukebox.github.io/2017/09/30/firstclass/</id>
    <published>2017-09-29T15:00:00.000Z</published>
    <updated>2017-12-26T21:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/python.png" alt=""></p><p>함수형 프로그래밍(functional programming) 을 공부하다보면, 가장 많이 나오는 말이 “일급 객체”, 혹은 “일급 시민” 일 겁니다. 일급 객체가 무엇인지 파이썬의 함수를 예시로 들어 알아보는 포스팅입니다.</p><a id="more"></a><p>일급 객체, 일급 함수라는 개념은 영국의 크리스토퍼 스트레이치라는 컴퓨터 과학자가 1960 년에 처음 소개한 개념이다. 일급 객체가 되려면 다음과 같은 조건을 만족해야 한다.</p><ul><li>변수나 데이터 구조 안에 담을 수 있다.</li><li>매개변수로 전달이 가능하다.</li><li>리턴값으로 사용될 수 있다.</li></ul><h2 id="파이썬의-함수는-일급-객체이다"><a href="#파이썬의-함수는-일급-객체이다" class="headerlink" title="파이썬의 함수는 일급 객체이다"></a>파이썬의 함수는 일급 객체이다</h2><p>해당 조건을 보면, <strong>파이썬의 함수는 일급 객체이다</strong> 라는 결론을 쉽게 도출할 수 있다. 왜냐하면 파이썬의 함수는 파라메터로 넘길 수 있고, 리턴값으로 사용될 수 있기 때문이다.</p><h3 id="변수나-데이터-구조-안에-담을-수-있다"><a href="#변수나-데이터-구조-안에-담을-수-있다" class="headerlink" title="변수나 데이터 구조 안에 담을 수 있다"></a>변수나 데이터 구조 안에 담을 수 있다</h3><p>파이썬의 함수는 변수에 할당할 수 있다. 다음 <code>greeting.py</code> 코드를 보면서 눈으로 확인해보자!</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello friend!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'See you later!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greeting = hello</span><br><span class="line">greeting()</span><br><span class="line">print(greeting)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">greeting = bye</span><br><span class="line">greeting()</span><br><span class="line">print(greeting)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(type(greeting))</span><br></pre></td></tr></table></figure><p>greeting 은 function 타입의 변수이고, 처음에는 hello 였다가 나중에는 bye 로 바뀐 것을 볼 수 있을 것이다. 실행 결과와 greeting 의 타입을 확인해 보면 다음과 같다.</p><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">$ python greeting.py</span><br><span class="line">Hello friend!</span><br><span class="line">&lt;<span class="function"><span class="keyword">function</span> <span class="title">hello</span> <span class="title">at</span> 0<span class="title">x101863c80</span>&gt;</span></span><br><span class="line"></span><br><span class="line">See you later!</span><br><span class="line">&lt;<span class="function"><span class="keyword">function</span> <span class="title">bye</span> <span class="title">at</span> 0<span class="title">x101863d08</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="매개변수로-전달이-가능하다"><a href="#매개변수로-전달이-가능하다" class="headerlink" title="매개변수로 전달이 가능하다"></a>매개변수로 전달이 가능하다</h3><p>또한, 파이썬의 함수는 매개변수로 전달이 가능하다. 다음의 <code>addition.py</code> 코드를 보면서 눈으로 알아보자.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(func, arg1, arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'calculation:'</span>, func.__name__)</span><br><span class="line">    print(<span class="string">'result:'</span>, func(arg1, arg2))</span><br><span class="line"></span><br><span class="line">calculate(add_two, <span class="number">4</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><code>calculate</code> 함수에 <code>add_two</code> 함수를 넘긴 것을 볼 수 있다!<br>위의 코드를 실행하면 당연하게도, 다음과 같은 결과가 나온다.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">python</span> addition.<span class="keyword">py</span></span><br><span class="line">calculation: add_two</span><br><span class="line">resul<span class="variable">t:</span> <span class="number">14</span></span><br></pre></td></tr></table></figure><p>이런 표현법의 장점은, 기능을 수정하고 싶을 때에도 기존 코드를 전혀 수정하지 않고 기능 수정이 가능하는 점이다. 예를 들어, <code>calculate</code> 으로 두 수를 곱하는 연산을 행하고 싶다고 하면, <code>calculate</code> 함수를 전혀 수정하지 않은 채로, 두 수를 곱하는 함수 <code>multiply_two</code> 를 새로 정의한 후 <code>calculate</code> 함수에 인자로 넘겨주면 그만이다.</p><h3 id="리턴값으로-사용될-수-있다"><a href="#리턴값으로-사용될-수-있다" class="headerlink" title="리턴값으로 사용될 수 있다."></a>리턴값으로 사용될 수 있다.</h3><p>마지막으로, 파이썬의 함수는 리턴값으로 사용될 수 있다. 이것도 역시 눈으로 보면 이해가 쉽다.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">document_it</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Running function:'</span>, func.__name__)</span><br><span class="line">        print(<span class="string">'Positional arguments:'</span>, args)</span><br><span class="line">        print(<span class="string">'Keyword arguments:'</span>, kwargs)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Result:'</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> new_function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_ints</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_ints(3, 5) = 8</span></span><br><span class="line">decorated_add_ints = document_it(add_ints)</span><br><span class="line">print(decorated_add_ints(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>(어쩌다 보니 예제에서 일급객체의 세 가지 요소가 다 드러났다)<br><code>add_ints</code> 함수에 간단한 설명을 붙이려고 <code>document_it</code> 함수를 정의하였다. <code>document_it</code> 함수는 내부함수인 <code>new_function</code> 을 리턴하는 구조이다.<br>맨 밑의 두 줄도 유심히 살펴보자. <code>document_it</code> 함수에 <code>add_ints</code> 함수를 인자로 넘긴 후에, <code>decorated_add_ints</code> 에 저장하였다! 실행 결과를 살펴보면 다음과 같다.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">python</span> decorator.<span class="keyword">py</span></span><br><span class="line">Running <span class="function"><span class="keyword">function</span>: <span class="title">add_ints</span></span></span><br><span class="line">Positional <span class="keyword">argument</span><span class="variable">s:</span> (<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">Keyword <span class="keyword">argument</span><span class="variable">s:</span> &#123;&#125;</span><br><span class="line">Resul<span class="variable">t:</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>(이 예제는 파이썬의 또 다른 문법인 데코레이터(<code>decorator</code>) 입니다. 데코레이터에 대해서는 추후 포스팅으로 찾아뵙겠습니다.)</p><h2 id="추가-함수가-일급-객체인-언어와-그렇지-않은-언어"><a href="#추가-함수가-일급-객체인-언어와-그렇지-않은-언어" class="headerlink" title="추가 - 함수가 일급 객체인 언어와 그렇지 않은 언어"></a>추가 - 함수가 일급 객체인 언어와 그렇지 않은 언어</h2><p>이제 “일급 객체” 란 무엇이고, 파이썬의 함수가 왜 일급 객체인지 알 수 있게 되었다. 그렇다면 다른 언어는 어떨까?</p><ul><li>함수가 일급 객체인 언어 : Javascript, Scala, Go</li><li>함수가 일급 객체가 아님 : C, Java</li></ul><p>(위의 언어가 전부가 아닙니다! 실제로 함수형 프로그래밍 언어는 많이 존재합니다)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/python.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;함수형 프로그래밍(functional programming) 을 공부하다보면, 가장 많이 나오는 말이 “일급 객체”, 혹은 “일급 시민” 일 겁니다. 일급 객체가 무엇인지 파이썬의 함수를 예시로 들어 알아보는 포스팅입니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://gyukebox.github.io/categories/Python/"/>
    
      <category term="Functional Programming" scheme="http://gyukebox.github.io/categories/Python/Functional-Programming/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
      <category term="함수형프로그래밍" scheme="http://gyukebox.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
  </entry>
  
  <entry>
    <title>PyCon Korea 2017 참석후기</title>
    <link href="http://gyukebox.github.io/2017/08/15/pycon/"/>
    <id>http://gyukebox.github.io/2017/08/15/pycon/</id>
    <published>2017-08-14T15:00:00.000Z</published>
    <updated>2017-12-26T21:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/pycon.png" alt=""></p><p>국내 최대규모 파이썬 컨퍼런스인 파이콘! 올해는 직접 가서 겪어봤습니다.</p><a id="more"></a><p>파이콘! 이름만 들어도 무슨 행사일지 알것같은 이 행사는 파이썬 컨퍼런스이다. 국내 파이써니스타들을 대상으로 한 대규모 컨퍼런스에 올해는 나도 참석했다(나도 나름 파이써니스타라고 생각했고, 또한 파이썬을 좋아하기 때문이다).<br>사실 작년까지만 해도 이런 행사가 존재하는지 조차도 몰랐는데, 올해 처음 간 파이콘에서 상상 이상의 충격을 받았다. 받은 충격을 여러분들과 공유하고자 함께 글을 쓴다.</p><h2 id="엄청-많은-사람"><a href="#엄청-많은-사람" class="headerlink" title="엄청 많은 사람"></a>엄청 많은 사람</h2><p>기술적인 부분에서도 충격을 많이 받았지만, 가장 충격을 받았던 건 바로 사람 수였다. <strong>사람이 무지막지하게 많았다!</strong> 이 많은 사람들이 다 파이썬 하는 사람들이라니 라고 생각하니깐 소름이 돋았다. “진짜 파이썬은 대세구나”, “파이썬이 얼마나 좋으면 이렇게 많은 사람들이 쓸까” 라는 생각이 저절로 머릿속에 맴돌았다. 행사에 등록하고 행사장에 딱 들어가는 순간 한 몇 분동안 “와” 밖에 안나왔다. (사실 아직까지도 파이썬이 좋은지 잘 모르겠다. 파이썬 뉴비라서 그런가…)</p><p>행사장에 들어서자마자 사람들이 엄청 길게 줄을 서 있었는데, 그 곳으로 가보니깐 바로 젯브레인에서 이벤트를 하고 있었다! 한치의 망설임도 없이 기다렸다. 왜냐면 나름대로 젯브레인 IDE 애호가였으니깐(<code>PyCharm</code>, <code>IntelliJ IDEA</code>, <code>CLion</code>, <code>Gogland</code> 이렇게 네 개 쓸 정도면 나름 애호가라고 해도 되지 않을까). 오랜 기다림 끝에 얻은 것은 바로 스티커와 젯브레인 요요였다. “좋아 젯브레인 스티커라면 이정도는 기다릴수 있지” 하고 행사의 시작을 알리는 키노트를 들으러 갔다.</p><h2 id="키노트"><a href="#키노트" class="headerlink" title="키노트"></a>키노트</h2><p>파이콘의 시작을 알리는 키노트는 두 개의 세션이 있었다. 첫 번째 세션은 현재까지 파이썬이 어떻게 변화하였고, 어떤 영향을 주었는지에 대한, 말 그대로 “파이썬 변천사” 였다. 하지만 별로 잘 공감하지 못하였다. 파이썬 3 으로 파이썬을 시작했는데 파이썬 1, 파이썬 2 에 대한 내용을 알 리가 만무했다. 그러나 파이썬이 엄청 발전했구나 라는 생각을 들었다. 지금 파이썬 3 에서 편리하게 쓰고 있는 기능들이 예전 버전에서는 안 됬다는 것을 들으니깐 말이다.<br>두 번째 세션은 파이콘을 준비한 분께서 엄청 재미있게 발표를 하셨는데, 기억에 남았던 것은 발표자분이 2014 년 파이콘에서 한 발표와 2016 년 파이콘에서 한 발표에서, 청중들의 웃음 빈도를 분석하여 “웃음 지수” 로 나타내어서, 발표가 얼마나 재미있었는가를 분석하는 프로젝트였다. 프로젝트 주제 뿐만 아니라, 파이썬의 활용도에서도 놀랐다.</p><p>이렇게 키노트가 끝났고, 밥을 먹고 와서 여러 가지 발표를 들으러 다녔다.</p><h2 id="세션"><a href="#세션" class="headerlink" title="세션"></a>세션</h2><p>컨퍼런스의 꽃인 세션! 파이콘 역시 국내 최대의 파이썬 컨퍼런스 답게 여러 가지 분야와 난이도의 세션이 마련되어 있었다. 발표자분 들 중에 내가 아는 분도 있었다! <del>하지만 안타깝게도 듣고싶었던 다른 세션과 시간이 완벽하게 겹쳐서 듣지 못했다.</del></p><p>세션은 한 분야에 치중해서 듣기보다는, 여러 분야에 걸쳐서 세션을 들었다. 분야라면 웹 개발, 데이터 분석, 딥러닝 정도가 있었다.</p><p><strong>웹 개발</strong> 세션에서는 주로 장고(<code>django</code>) 를 다뤘다. 장고를 경험해본 나로써는 세션들이 유익했다. 주로 장고 관련 꿀팁들(성능 개선 등) 과 숨겨진 기능들 을 다뤘다.</p><p><strong>데이터 분석</strong> 세션에서는 많은 공감이 되지 않았지만, (<del>데이터 분석에 관심이 별로 없었기 때문에</del>) “데이터로 보는 파이콘” 세션이 인상깊었다. 역대 파이콘 예산을 분석한 세션이었는데, 파이콘 준비하신 분들의 노고가 느껴지는 세션이었다.</p><p>하지만 뭐니뭐니해도 가장 인상깊었던 세션은 바로 <strong>딥러닝</strong> 세션이었다. 올해 파이콘 모토가 “Back to the Basic” 이었던 것 만큼이나, 발표자 분들이 엄청 쉽고 재미있게 발표를 잘 해 주셨다. 딥러닝이 무엇인가 부터 시작해서 프레임워크 소개까지, 무엇 하나 빠지는 게 없었다. 또한, 딥러닝의 결과물을 눈으로 보니 <strong>신기하고 재미있었다</strong>. 컴퓨터가 학습을 해서 결과물을 만들어낸다니, 놀라지 않을 수 없었다.<br>딥러닝 세션들을 듣고 엄청 감동받은 나머지, 행사장에서 <strong>바로 딥러닝 책을 사버렸다!</strong> (파이콘 스폰서 중에서 출판사가 여러 곳 있었는데, 해당 출판사에서 행사 당일 부스를 차리고 책 10% 할인 이벤트를 진행하길래, 바로 사버렸다) 과연 올해가 가기 전까지 산 책을 볼 수는 있을까, <del>학교 과제하고 팀플하다 보면 시간이 다 갈텐데 가 아니라 게을러서</del><br>올해 목표가 하나 더 늘었다. 바로 <strong>딥러닝 입문하기</strong>. 1 학년때 학교 과제로 여러가지 게임을 만들었는데, 그 게임을 플레이하는 AI 를 만들어보는 것으로 공부를 해볼까 한다.</p><p><strong>클라우드</strong> 관련 세션이 하나 있었다(사실 이 세션 들으러 지인 개발자분의 발표 세션을 포기했다). 하지만, 세션은 기대했던 것보다 많이 달랐다.</p><p>영어 세션도 있었지만 잘 들어오지 않았다. <del>전날 블로그 서버 고치느라 잠을 세시간 정도밖에 못 자고 가서 그랬던 것 같다</del> 영어능력이 퇴화한 것 같다. 다시 영어 공부를 시작해야하나…</p><h2 id="라이트닝-토크-프리토킹"><a href="#라이트닝-토크-프리토킹" class="headerlink" title="라이트닝 토크 + 프리토킹"></a>라이트닝 토크 + 프리토킹</h2><p>사실 이 항목이 파이콘의 재미를 두 배로 만들어줬다. 행사장 내에서는, 주제를 정하여 해당 주제에 관심 있는 사람들이 자유롭게 토론할 수 있는 공간이 있었는데, 나 또한 거기 가서 엄청 열심히 떠들었다. 역시 개발 관련 아무말 대잔치는 재밌다.</p><p>같이 프리토킹하러 오신 분들 중에 중학교 2 학년 분이 한 분 계셨다! 그분 말로는 스크래치(여러분들이 생각하시는 그 고양이 있는 스크래치가 맞습니다) 로 코딩을 시작하다가 재밌어서 계속 하게 되셨다고. 중학교 2 학년 분이 방에서 동일한 수준으로 토킹이 가능했다는 게 너무 놀랐다. 난 중 2 때 뭐했지…</p><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><p>여러 스타트업에서 부스를 차리고 홍보를 했다. 모든 부스를 다 돈 결과, <strong>스티커를 엄청 많이 받았다</strong>. 레진엔터테인먼트, 스마트스터디 같은 이름있는 스타트업 부터 처음 들어보는 스타트업 까지 엄청 많았다. 스타트업에 대한 로망이 한층 더 상승했다. 스타트업 가고 싶다!</p><p>기념품을 엄청 많이 받았다. 대충 나열해보자면,</p><ul><li>여러 종류의 개발스티커</li><li>파이콘 후드 + 에코백</li><li>IBM 티셔츠</li><li>엘라스틱서치(<code>elasticsearch</code>) 티셔츠</li><li>젯브레인 요요</li></ul><p>요 정도 되는것 같다.</p><p>여기까지가 저의 후기였습니다. 결론은, 파이썬 하는 사람들한테 엄청 좋은 컨퍼런스인 것 같습니다. 내년에는 아마 더 큰 규모로 파이콘이 열릴 거라고 하네요. 엄청 유익한 행사였습니다 다음에는 꼭 참여해보세요!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/pycon.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;국내 최대규모 파이썬 컨퍼런스인 파이콘! 올해는 직접 가서 겪어봤습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="컨퍼런스 후기" scheme="http://gyukebox.github.io/categories/%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4-%ED%9B%84%EA%B8%B0/"/>
    
    
      <category term="Python" scheme="http://gyukebox.github.io/tags/Python/"/>
    
      <category term="PyCon" scheme="http://gyukebox.github.io/tags/PyCon/"/>
    
      <category term="컨퍼런스" scheme="http://gyukebox.github.io/tags/%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4/"/>
    
      <category term="후기" scheme="http://gyukebox.github.io/tags/%ED%9B%84%EA%B8%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git 입문자를 위한 git 사용법</title>
    <link href="http://gyukebox.github.io/2017/08/10/git/"/>
    <id>http://gyukebox.github.io/2017/08/10/git/</id>
    <published>2017-08-09T15:00:00.000Z</published>
    <updated>2017-12-26T21:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/git.png" alt=""></p><p>개발할 때 코딩 실력이나만큼 중요한 것은 바로 버전 관리죠. 현재 거의 필수적으로 쓰이는 버전 관리 툴인 git 에 관하여 알아보는 포스트입니다. (git 을 아예 모르는 사람들을 대상으로 포스팅했습니다.)</p><a id="more"></a><p>해당 포스트에서는 터미널 명령어를 사용합니다. 터미널이 아직까지는 어려우신 분들은 <code>SourceTree</code> 를 활용하셔도 좋습니다(<code>SourceTree</code>에 관해서는 아래에 자세하게 명시하겠습니다).</p><h2 id="버전-관리-툴의-필요성"><a href="#버전-관리-툴의-필요성" class="headerlink" title="버전 관리 툴의 필요성"></a>버전 관리 툴의 필요성</h2><p>학교에서 팀 프로젝트를 해봤다면 이런 경험이 한 번쯤은 있었을 것이다.</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">철수 : <span class="comment">(압축파일을 푼다)</span> 영희야, 너가 보내준 파일 받았는데 여기 OOOO한 부분에서 문제가 있어.</span><br><span class="line">      그리고 그때 말한 그 부분 내가 만들었어. 파일 보냈어! <span class="comment">(코드를 압축해서 카카오톡으로 보낸다)</span></span><br><span class="line">영희 : <span class="comment">(압축파일을 푼다)</span> 그런데 철수야, 그렇게 만들면 내가 만든 부분이랑 자료형이 달라서 안 맞아.</span><br><span class="line">      이러이렇게 만들어서 다시 보내줘. 내가 만든 부분을 지금 수정하기 힘들어.</span><br><span class="line">철수 : <span class="comment">(한숨을 쉬며)</span> 그래 알았어... <span class="comment">(새로 만든 코드를 압축해서 카카오톡으로 보낸다)</span></span><br><span class="line">      여기 다 만들었다.</span><br><span class="line">영희 : 헉 잠시만 철수야, 앞에 만든 부분이 문제가 생겨서 수정해야 할 것 같거든?</span><br><span class="line">      <span class="comment">(압축파일을 풀고 수정을 시도하지만, 역시 안 맞는 부분이 있다)</span></span><br><span class="line">      그런데 이제는 ㅁㅁㅁㅁ한 부분에서 안 맞아. 다시 수정해야 되겠는데?</span><br><span class="line">철수, 영희 : 하...</span><br></pre></td></tr></table></figure><p>보기만 해도 답답한 <del>암걸리는</del> 상황이다. 이럴 때, 서로의 코드에서 다른 부분을 알아서 잡아주는 도구가 있었으면 얼마나 편했을까?<br>또한, 카카오톡으로 매번 압축해서 파일을 보내고 압축을 풀고… 이런 불편한 작업 없이 소스코드를 한 곳에 모아서 관리할 수 있는 도구가 있었으면 얼마나 좋았을까?</p><p>이런 상황에서 사용하도록 만들어진 도구가 <code>git</code> 이다! <code>git</code>을 이용하면 위의 상황에서 훨씬 편리하게 작업중인 소스코드를 관리하는 것이 가능하다. 이제 <code>git</code>에 관하여 자세하게 알아보자!</p><h2 id="Git-설치하기"><a href="#Git-설치하기" class="headerlink" title="Git 설치하기"></a>Git 설치하기</h2><p>가장 먼저 할 일은, 역시나 설치이다. 설치 방법은 다음과 같다.</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>리눅스 배포판에 따라 다음 두 명령어 중 하나를 입력한다. (하나가 안되면 다른 거다)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install git</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install git</span><br></pre></td></tr></table></figure><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p><code>Homebrew</code>가 설치되어 있다면, 다음 명령어만 입력하면 된다.</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>git</span><br></pre></td></tr></table></figure><p>(Homebrew 는 맥용 패키지 관리 도구입니다. 설치 방법 및 자세한 내용은 <a href="https://brew.sh/index_ko.html" target="_blank" rel="noopener">https://brew.sh/index_ko.html</a> 를 참고하세요.)</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>안타깝게도, 윈도우에서는 커맨드라인 하나만으로 git 을 설치할 수 없기에, 공식 사이트(<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a>) 를 통해 설치하거나, <code>SourceTree</code>나 <code>Github Desktop</code> 같은 GUI 도구를 이용해야 한다. Command line tool 은 <a href="https://git-for-windows.github.io" target="_blank" rel="noopener">https://git-for-windows.github.io</a> 에서 다운로드 받을 수 있다.</p><p>(사실 초보자들한테는 GUI 툴이 더 시작하기는 좋습니다.)<br>(윈도우 10 부터는 cmd 에서 bash 명령어를 이용하는 것이 가능해졌습니다. 하지만, 많이 부족하여 아직 사용하기는 시기상조다 라는 의견이 많습니다.)</p><p>운영체제에 맞게 git 을 설치하였으면, 사용할 준비가 되었다!</p><h2 id="Git-시작하기"><a href="#Git-시작하기" class="headerlink" title="Git 시작하기"></a>Git 시작하기</h2><p>이제 git 을 본격적으로 사용해 보자!</p><h3 id="저장소-생성하기"><a href="#저장소-생성하기" class="headerlink" title="저장소 생성하기"></a>저장소 생성하기</h3><p>철수는 저번 프로젝트를 교훈삼아, 이번 프로젝트에서는 꼭 버전 관리 도구를 사용하기로 마음먹었고, git 을 사용하기로 하였다.<br>우선, 그는 자신이 작업중인 프로젝트 폴더로 들어가서, 다음 명령어로 git 을 시작했다.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /path/to/project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p><code>git init</code> 명령어를 사용하면 현재 작업중인 프로젝트 폴더에 <code>.git</code> 이라는 숨김 파일이 만들어지고,<br>“git 저장소”가 생성된다. git 은 <code>.git</code> 파일이 위치하는 디렉토리 및 하위 디렉토리에 위치해 있는 파일들을 관리한다.<br>만약 각자 다른 프로젝트를, 따로 관리하고 싶다면, 각각의 프로젝트 폴더에서 각자 <code>git init</code> 을 사용해 주어야 한다.</p><h3 id="gitignore-파일"><a href="#gitignore-파일" class="headerlink" title=".gitignore 파일"></a>.gitignore 파일</h3><p>하지만, 모든 파일을 버전 관리에 포함하고 싶지는 않다. 가령 소스 파일을 빌드해서 만들어진 실행파일이나, 이미지 파일이나, 아니면 IDE 에서 자동으로 생성되지만 필요가 없는 폴더의 파일들(예: JetBrains IDE 의 <code>.idea</code>) 같은 경우는, 딱히 버전 관리를 해줄 필요가 없다.<br>Git 은 이렇게 사용자가 버전 관리를 하고 싶지 않은 파일들을 무시할 수 있는 기능이 있다. Git 이 무시하도록 하는 파일들을 명시하는 파일이 <code>.gitignore</code> 파일이다.</p><p>다시 철수로 돌아가보자. 철수는 자신이 작업하고 있는 프로젝트의 파일 중, 이미지 파일을 포함한 몇몇 파일은 버전 관리의 필요성을 느끼지 않아서, <code>.gitignore</code> 파일에 이를 추가했다.</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.gitignore</span><br><span class="line">*.jpg</span><br><span class="line">*.png</span><br><span class="line">.idea<span class="comment">/*</span></span><br><span class="line"><span class="comment">.DS_Store</span></span><br></pre></td></tr></table></figure><p>(해당 예시는 그냥 예시일 뿐입니다. 꼭 이렇게 작성하라는 뜻이 아니라, 여러분들의 필요에 맞게 <code>.gitignore</code> 파일을 작성하시면 됩니다.)</p><p>예시를 자세히 보면 <code>.gitignore</code> 파일에서 무시 파일을 명시하는 방법은 아래와 같이 세 가지가 있음을 알 수 있는데,</p><ul><li>확장자를 명시하여 해당 확장자의 파일을 모두 무시</li><li>디렉토리를 명시하여 해당 디렉토리 아래의 파일을 모두 무시 (이 경우 subdirectory 도 포함)</li><li>파일 이름을 정확히 명시하여 해당 파일을 무시</li></ul><p>뭐 상황에 맞게 세 가지 방법 중 하나를 사용하면 된다.</p><h2 id="파일의-상태"><a href="#파일의-상태" class="headerlink" title="파일의 상태"></a>파일의 상태</h2><p>Git 에서는 현재 작업중인 프로젝트 파일의 상태를 다음과 같이 세 가지로 분류한다.</p><ul><li>작업 중인 상태</li><li>준비 상태</li><li>완료 상태</li></ul><p>그리고, git 저장소에는 (눈에는 보이지 않지만) 파일들의 상태를 구분하기 위하여 세 종류의 영역이 있는데,</p><ul><li><code>working directory</code> : 현재 작업 중인 실제 파일들</li><li><code>index</code> : 작업이 완료되어 확정을 준비하는 파일들 (이 영역에 파일들을 추가하는 행동을 <code>stage</code> 라고 한다)</li><li><code>HEAD</code> : 최종 확정본들 (이 영역에 파일을 추가하는 행동을 <code>commit</code> 이라고 한다)</li></ul><p><del>왜 HEAD 만 대문자일까</del><br>위와 같다. 그렇다면, git 에서 소스코드를 관리하는 과정은 다음과 같다는 것을 알 수 있게 된다.</p><ol><li>소스 코드 작업을 완료한다.</li><li>작업이 완료된 코드를 <code>index</code>에 <code>stage</code> 한다 (또는 스테이지에 올린다).</li><li>필요한 파일들을 모두 <code>stage</code> 했으면 묶어서 <code>HEAD</code>에 <code>commit</code>(커밋) 한다.</li></ol><p><del>어때요 참 쉽죠?</del><br>예를 들어, 철수는 웹사이트를 하나 제작하기 위해서 맨 처음 화면인 <code>index.html</code> 을 처음 만들었다고 하자. 그러면 철수는 이 “<code>index.html</code> 제작” 을 하나의 버전(단계) 로 생각하여, git 에서 <code>stage</code> 후 <code>commit</code> 으로 관리할 수 있게 된 것이다.</p><h2 id="상태-확인과-staging"><a href="#상태-확인과-staging" class="headerlink" title="상태 확인과 staging"></a>상태 확인과 staging</h2><p>철수는 소스 코드 작업을 마치고 현재 git 저장소의 상태를 알아보기 위하여 다음 명령어를 사용했다.<br><code>git status</code><br>이 명령어를 입력하니 다음과 같이 현재 파일들의 상태가 한 눈에 보였다.</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial <span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line"><span class="keyword">nothing</span> added <span class="keyword">to</span> <span class="keyword">commit</span> but untracked files <span class="keyword">present</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">to</span> track)</span><br></pre></td></tr></table></figure><p><code>git status</code> 명령어를 사용하면, 현재 어떤 파일이 추가되고 삭제되었는지, 어떤 파일이 아직 추가되지 않았는지 볼 수 있다. 심지어 “추가하려면 <code>git add</code> 를 쓰세요” 라고 친절하게 알려준다! 그렇다, 파일을 <code>index</code>에 <code>stage</code> 하고 싶으면 <code>git add</code>를 사용하면 된다.</p><p>철수는 작업이 완료된 파일을 스테이지에 올리기 위하여 다음과 같이 진행했고, 상황을 한번 더 확인했다.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">add</span> <span class="built_in">index</span>.html</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">file</span>:   <span class="built_in">index</span>.html</span><br></pre></td></tr></table></figure><p><code>git add &lt;파일이름&gt;</code> 을 사용해서 해당 파일을 스테이지에 올릴 수 있다.<br><code>git status</code> 를 사용하면, 스테이지에 올라간 파일들은 “change to be committed: “ 라는 문구 아래에 놓이고, 아직 스테이지에 올라가지 않은 파일들은 “untracked files: “ 라는 문구 아래에 놓이게 된다.</p><p>하지만, 일일이 모든 파일을 추가하자니 좀 귀찮은 감이 있다. 위와 같이 하나의 파일만을 추가하는 명령 말고도, 다음과 같은 표현들을 사용하면 한번에 여러 개의 파일들을 동시에 스테이지에 올릴 수가 있다.</p><ul><li><code>git add *.foo</code> : foo 확장자를 가진 모든 파일들을 스테이지에 올린다.</li><li><code>git add dir/*</code> : dir 디렉토리 안의 모든 파일들을 스테이지에 올린다.</li><li><code>git add --all</code> : 아직 스테이지에 올라가지 않은 모든 파일들을 스테이지에 올린다.</li></ul><p>하지만, 동일 확장자나 동일 디렉토리 안에 현재 버전에 포함시키고 싶지 않은 파일이 들어 있을 수도 있으므로 신중하게 써야 한다.</p><h2 id="Commit-과-commit-message"><a href="#Commit-과-commit-message" class="headerlink" title="Commit 과 commit message"></a>Commit 과 commit message</h2><p>철수는 필요한 모든 파일들을 스테이지에 올렸다. 스테이지에 올라간 파일들을 묶어서 커밋하기 위하여 다음과 같이 명령어를 사용하였다.</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"Initial commit : added index.html"</span></span><br><span class="line">[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) <span class="number">772</span>f2e6] <span class="keyword">Initial</span> <span class="keyword">commit</span> : added index.html</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">8</span> insertions(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> index.html</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">status</span></span><br><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span><br><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure><p>git 에 내용을 커밋할 때는 위와 같이 <code>git commit -m &quot;commit message&quot;</code> 라는 명령어를 사용한다. 그러면 친절하게 커밋의 내용을 보여준다. 또한 커밋 이후에 <code>git status</code> 로 상태를 확인하면 다음과 같이 보이게 된다. (물론 아직 커밋을 안 한 파일이 있으면 다르게 나온다.)</p><p>앞의 과정들과 약간 다른 점은, 커밋을 할 때에는 커밋 메시지(commit message) 를 작성한다는 점인데, 현재 개발자가 무슨 작업을 진행했는지 알 수 있도록 하기 위해서다. 따라서, 커밋 메시지는 <strong>간결하지만 자세하게</strong> 작성해야 한다! (<del>이것은 마치 따뜻한 냉커피..</del>)<br>길지 않으면서, 현재 작업을 통하여 예전과 변경된 점이 명확하게 드러나도록 작성하면 좋은 커밋 메시지가 될 수 있다.</p><h2 id="원격-저장소"><a href="#원격-저장소" class="headerlink" title="원격 저장소"></a>원격 저장소</h2><p>철수는 이제 작업한 내용을 영희한테 보여줄 준비가 되었다. 하지만 또 파일을 압축해서 카카오톡으로 보낸다는 건 상상도 하기 싫은 일. 따라서, 현재 저장소와 연동할 수 있는 <strong>원격 저장소</strong> 를 두기로 하였다. 그래서, 다음과 같이 했다.</p><p>우선 <code>GitHub</code> 에서 레포지토리를 하나 만들었다. 그 다음, 아래의 명령어로 깃허브 원격 저장소랑 현재 저장소를 연동시켰다.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/gyukebox/gittutorial.git</span><br></pre></td></tr></table></figure><p>(GitHub 저장소는 그냥 만들면 됩니다. 깃허브 가서 Create Repository 누르면 친절하게 나옵니다.)<br><code>git remote add [단축이름] [url]</code> 명령어를 사용하여 url 의 원격 저장소를 단축 이름을 사용하여 현재 git 저장소랑 연동시켰다(github 말고도 다른 원격 저장소들도 있지만, 거의 다 github 를 사용하므로 예시도 그냥 github 로 들겠습니다).</p><p>현재 저장소에 연동된 원격 저장소들을 보려면 다음과 같은 명령어를 사용하면 된다.</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">originhttps:<span class="regexp">//gi</span>thub.com<span class="regexp">/gyukebox/gi</span>ttutorial.git (fetch)</span><br><span class="line">originhttps:<span class="regexp">//gi</span>thub.com<span class="regexp">/gyukebox/gi</span>ttutorial.git (push)</span><br></pre></td></tr></table></figure><p>여기서 <code>-v</code> 옵션은 verbose 의 의미로, “자세히” 라는 뜻이다. 저 옵션을 붙이지 않으면 그냥 단축 이름만 나오지만, 옵션을 붙이면 원격 저장소 url 과 같이 나온다.</p><h3 id="원격-저장소에-올리기-push"><a href="#원격-저장소에-올리기-push" class="headerlink" title="원격 저장소에 올리기(push)"></a>원격 저장소에 올리기(push)</h3><p>이제 원격 저장소도 만들었으니, 원격 저장소에 현재 작업한 내용들을 올리는 일만 남았다. 철수는 다음과 같이 현재 작업 내용을 올렸다.</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting object<span class="variable">s:</span> <span class="number">3</span>, done.</span><br><span class="line">Delta compression using <span class="keyword">up</span> <span class="keyword">to</span> <span class="number">8</span> threads.</span><br><span class="line">Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">314</span> bytes | <span class="number">0</span> bytes/s, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To http<span class="variable">s:</span>//github.<span class="keyword">com</span>/gyukebox/gittutorial.git</span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; master</span><br></pre></td></tr></table></figure><p><code>git push [원격 단축이름] [브랜치]</code> 명령어를 사용하면, 해당 단축이름을 가지는 원격 저장소로 코드가 올라가게 된다. 여기서 <code>master</code>는 <strong>브랜치</strong> 인데, 2 명 이상이 협업할 때 아주 중요한 개념이 된다(<code>master</code>는 기본 브랜치 이름입니다. 브랜치에 관해서는 아직 자세히 모르셔도 됩니다. 추후 포스팅으로 찾아뵙겠습니다).</p><p>이제 철수는 원격 저장소를 통하여 소스 코드를 올리므로 더 이상 영희에게 파일을 압축하여 카카오톡으로 보내지 않아도 된다! 영희가 해당 저장소 링크로 들어가서 코드를 확인하면 그만이니깐.</p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><p><code>git</code> 에 관한 아주 기본적인 개념들을 알아봤는데, 간단하게 정리하면 다음과 같이 요약할 수 있다.</p><ul><li><code>git init</code> : 새로운 git 저장소를 만든다.</li><li><code>git status</code> : 현재 저장소의 상황을 본다.</li><li><code>git add &lt;file&gt;</code> : 파일을 스테이지에 올린다.</li><li><code>git commit -m &quot;commit message&quot;</code> : 메시지와 함께 커밋한다.</li><li><code>git remote add [name] [url]</code> : 원격 저장소를 추가한다.</li><li><code>git push [remote] [branch]</code> : 원격 저장소에 올린다.</li></ul><h2 id="앞으로-더-알아볼-내용"><a href="#앞으로-더-알아볼-내용" class="headerlink" title="앞으로 더 알아볼 내용"></a>앞으로 더 알아볼 내용</h2><p>(추후 포스팅으로 해당 개념들에 대하여 설명하겠습니다.)</p><ul><li>원격 저장소에서 가져오기 : <code>pull</code> 과 <code>clone</code></li><li>원격 저장소의 설명을 담당하는 <code>README.md</code></li><li>브랜치(branch)</li><li><code>pull request</code> 와 <code>merge</code></li><li><code>rebase</code></li></ul><h2 id="참고한-글들"><a href="#참고한-글들" class="headerlink" title="참고한 글들"></a>참고한 글들</h2><ul><li><a href="https://rogerdudler.github.io/git-guide/index.ko.html" target="_blank" rel="noopener">https://rogerdudler.github.io/git-guide/index.ko.html</a></li><li><a href="http://blog.weirdx.io/post/45529" target="_blank" rel="noopener">http://blog.weirdx.io/post/45529</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/git.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;개발할 때 코딩 실력이나만큼 중요한 것은 바로 버전 관리죠. 현재 거의 필수적으로 쓰이는 버전 관리 툴인 git 에 관하여 알아보는 포스트입니다. (git 을 아예 모르는 사람들을 대상으로 포스팅했습니다.)&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://gyukebox.github.io/categories/git/"/>
    
    
      <category term="git" scheme="http://gyukebox.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Welcome to GyuLog!</title>
    <link href="http://gyukebox.github.io/2017/08/08/welcome/"/>
    <id>http://gyukebox.github.io/2017/08/08/welcome/</id>
    <published>2017-08-07T15:00:00.000Z</published>
    <updated>2017-12-26T21:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>저의 블로그에 오신 것을 환영합니다! 앞으로 이곳을 개발 이야기들로 채워보겠습니다.</p><a id="more"></a><p>포스팅들의 주제는,</p><ul><li><code>Python</code>, <code>JavaScript</code>, <code>Cloud Computing</code> 관련 기술 이야기</li><li>Data Science, Machine Learning 관련 기술 이야기</li><li>컨퍼런스 및 여러 개발 행사 참여 후기</li><li><del>저의 삽질 후기</del></li></ul><p>가 될 것 같습니다. 다시 한번 환영합니다!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;저의 블로그에 오신 것을 환영합니다! 앞으로 이곳을 개발 이야기들로 채워보겠습니다.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
